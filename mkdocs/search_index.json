{
    "docs": [
        {
            "location": "/", 
            "text": "ValidatedNumerics.jl\n\n\nValidatedNumerics.jl\n is a Julia package for performing \nValidated Numerics\n in Julia, i.e. \nrigorous\n computations with finite-precision floating-point arithmetic.\n\n\nInstallation\n\n\nTo install the package, from within Julia do\n\n\njulia\n Pkg.add(\"ValidatedNumerics\")\n\n\n\nInterval arithmetic\n\n\nAll calculations are carried out using \ninterval arithmetic\n: all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is \nguaranteed\n to contain the correct result, starting from the given initial data.\n\n\nThe aim of the package is correctness over speed, although performance considerations are also taken into account\n\n\nContents:\n\n\n\n\nBasic usage\n\n\nMulti-dimensional\n\n\nRoot finding\n\n\nRounding\n\n\nDecorations\n\n\n\n\nBibliography\n\n\n\n\nValidated Numerics: A Short Introduction to Rigorous Computations\n, W. Tucker, Princeton University Press (2010)\n\n\nIntroduction to Interval Analysis\n, R.E. Moore, R.B. Kearfott \n M.J. Cloud, SIAM (2009)\n\n\n\n\nRelated packages\n\n\n\n\nMPFI.jl\n, a Julia wrapper around the \nMPFI C library\n, a multiple-precision interval arithmetic library based on MPFR\n\n\nIntervals.jl\n, an alternative implementation of basic interval functions.\n\n\nUnums.jl\n, an implementation of interval\narithmetic with variable precision (\"ubounds\")\n\n\n\n\nAuthors\n\n\n\n\nLuis Benet\n, Instituto de Ciencias F\u00edsicas,\nUniversidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\nDavid P. Sanders\n,\nDepartamento de F\u00edsica, Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\n\n\nContributors\n\n\n\n\nOliver Heimlich\n\n\nNikolay Kryukov\n\n\nJohn Verzani\n\n\n\n\nAcknowledgements\n\n\nThis project was developed in a masters' course in the postgraduate programs in Physics and in Mathematics at UNAM during the second semester of 2013 and the first semester of 2015. We thank the participants of the courses for putting up with the half-baked material and contributing energy and ideas.\n\n\nFinancial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214. LB acknowledges support through a \nC\u00e1tedra Moshinsky\n (2013).\nDPS acknowledges a sabbatical fellowship from CONACYT and thanks Alan Edelman and the Julia group at MIT for hosting his sabbatical visit.", 
            "title": "Package"
        }, 
        {
            "location": "/#validatednumericsjl", 
            "text": "ValidatedNumerics.jl  is a Julia package for performing  Validated Numerics  in Julia, i.e.  rigorous  computations with finite-precision floating-point arithmetic.", 
            "title": "ValidatedNumerics.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "To install the package, from within Julia do  julia  Pkg.add(\"ValidatedNumerics\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#interval-arithmetic", 
            "text": "All calculations are carried out using  interval arithmetic : all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is  guaranteed  to contain the correct result, starting from the given initial data.  The aim of the package is correctness over speed, although performance considerations are also taken into account", 
            "title": "Interval arithmetic"
        }, 
        {
            "location": "/#contents", 
            "text": "Basic usage  Multi-dimensional  Root finding  Rounding  Decorations", 
            "title": "Contents:"
        }, 
        {
            "location": "/#bibliography", 
            "text": "Validated Numerics: A Short Introduction to Rigorous Computations , W. Tucker, Princeton University Press (2010)  Introduction to Interval Analysis , R.E. Moore, R.B. Kearfott   M.J. Cloud, SIAM (2009)", 
            "title": "Bibliography"
        }, 
        {
            "location": "/#related-packages", 
            "text": "MPFI.jl , a Julia wrapper around the  MPFI C library , a multiple-precision interval arithmetic library based on MPFR  Intervals.jl , an alternative implementation of basic interval functions.  Unums.jl , an implementation of interval\narithmetic with variable precision (\"ubounds\")", 
            "title": "Related packages"
        }, 
        {
            "location": "/#authors", 
            "text": "Luis Benet , Instituto de Ciencias F\u00edsicas,\nUniversidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)  David P. Sanders ,\nDepartamento de F\u00edsica, Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)", 
            "title": "Authors"
        }, 
        {
            "location": "/#contributors", 
            "text": "Oliver Heimlich  Nikolay Kryukov  John Verzani", 
            "title": "Contributors"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "This project was developed in a masters' course in the postgraduate programs in Physics and in Mathematics at UNAM during the second semester of 2013 and the first semester of 2015. We thank the participants of the courses for putting up with the half-baked material and contributing energy and ideas.  Financial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214. LB acknowledges support through a  C\u00e1tedra Moshinsky  (2013).\nDPS acknowledges a sabbatical fellowship from CONACYT and thanks Alan Edelman and the Julia group at MIT for hosting his sabbatical visit.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/usage/", 
            "text": "MathJax.Hub.Config({\n    TeX: { equationNumbers: { autoNumber: \"AMS\" } }\n  });\n  MathJax.Hub.Config({\n    TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\", \"autobold.js\", \"autoload-all.js\"] }\n  });\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n      processEscapes: true\n    }\n  });\n\n\n\n\n\n\n\n\n\nBasic usage\n\n\nThe basic elements of the package are \nintervals\n, i.e. sets of real numbers (possibly including $\\pm \\infty$) of the form\n\n\n$$[a, b] := { a \\le x \\le b } \\subseteq \\mathbb{R}.$$\n\n\nCreating intervals\n\n\nIntervals are created using the \n@interval\n macro, which takes one or two expressions:\n\n\njulia\n using ValidatedNumerics\n\njulia\n a = @interval(1)\n[1, 1]\n\njulia\n typeof(ans)\nInterval{Float64} (constructor with 1 method)\n\njulia\n b = @interval(1, 2)\n[1, 2]\n\n\n\n\nThese return objects of the parametrised type \nInterval\n, the basic object in the package.\nBy default, \nInterval\n objects contain \nFloat64\ns, but the library also allows using\n\nBigFloat\ns, for example:\n\n\njulia\n @biginterval(1, 2)\n[1, 2]\u2082\u2085\u2086\n\njulia\n showall(ans)\nInterval(1.000000000000000000000000000000000000000000000000000000000000000000000000000000, 2.000000000000000000000000000000000000000000000000000000000000000000000000000000)\n\n\n\n\nThe constructor of the \nInterval\n type may be used directly, but this is generally not recommended, for the following reason:\n\n\njulia\n a = Interval(0.1, 0.3)\n[0.1, 0.3]\n\njulia\n b = @interval(0.1, 0.3)\n[0.0999999, 0.300001]\n\n\n\n\nWhat is going on here?\n\n\nDue to the way floating-point arithmetic works, the interval\n\na\n created directly by the constructor turns out to contain\n\nneither the true real number 0.1, nor 0.3\n.\nThe \n@interval\n macro, however, uses \ndirected rounding\n to \nguarantee\n\nthat the true 0.1 and 0.3 are included in the result.\n\n\nBehind the scenes, the \n@interval\n macro rewrites the expression(s) passed to it, replacing the literals (0.1, 1, etc.) by calls to create correctly-rounded intervals, handled by the \nconvert\n\nfunction.\n\n\nThis allows us to write, for example\n\n\njulia\n @interval sin(0.1) + cos(0.2)\n[1.07989, 1.0799]\n\n\n\n\nwhich is equivalent to\n\n\njulia\n sin(@interval(0.1)) + cos(@interval(0.2))\n[1.07989, 1.0799]\n\n\n\n\nThis can be used together with user-defined functions:\n\n\njulia\n f(x) = 2x\nf (generic function with 1 method)\n\njulia\n f(@interval(0.1))\n[0.199999, 0.200001]\njulia\n @interval f(0.1)\n[0.199999, 0.200001]\n\n\n\n\n$\\pi$\n\n\nYou can create correctly-rounded intervals containing $\\pi$:\n\n\njulia\n @interval(pi)\n[3.14159, 3.1416]\n\n\n\n\nand embed it in expressions:\n\n\njulia\n @interval(3*pi/2 + 1)\n[5.71238, 5.71239]\n\njulia\n @interval 3\u03c0/2 + 1\n[5.71238, 5.71239]\n\n\n\n\nConstructing intervals\n\n\nIntervals may be constructed using rationals:\n\n\njulia\n @interval(1//10)\n[0.0999999, 0.100001]\n\n\n\n\nReal literals are handled by internally converting them\nto rationals (using the Julia function \nrationalize\n). This gives\na result that contains the computer's \"best guess\" for\nthe real number the user \"had in mind\":\n\n\njulia\n @interval(0.1)\n[0.0999999, 0.100001]\n\n\n\n\nIf you instead know which exactly-representable floating-point number $a$ you need and really\nwant to make a \nthin interval\n, i.e., an interval of the form $[a, a]$,\ncontaining precisely one float, then you can\nuse the \nInterval\n constructor directly:\n\n\njulia\n a = Interval(0.1)\n[0.1, 0.100001]\n\njulia\n showall(a)\nInterval(0.1, 0.1)\n\n\n\n\nHere, the \nshowall\n function shows the internal representation of the interval,\nin a reproducible form that may be copied and pasted directly. It uses Julia's\ninternal function (which, in turn, uses the so-called Grisu algorithm) to show\nexactly as many digits are required to give an unambiguous floating-point number.\n\n\nStrings may be used inside \n@interval\n:\n\n\njulia\n @interval \n0.1\n*2\n[0.199999, 0.200001]\n\njulia\n @biginterval \n0.1\n*2\n[0.199999, 0.200001]\u2082\u2085\u2086\n\njulia\n showall(ans)\nInterval(1.999999999999999999999999999999999999999999999999999999999999999999999999999983e-01, 2.000000000000000000000000000000000000000000000000000000000000000000000000000004e-01)\n\n\n\n\n\nStrings in the form of intervals may also be used:\n\n\njulia\n @interval \n[1.2, 3.4]\n\n[1.19999, 3.40001]\n\n\n\n\nIntervals can be created from variables:\n\n\njulia\n a = 3.6\n3.6\n\njulia\n b = @interval(a)\n[3.59999, 3.60001]\n\n\n\n\nThe upper and lower bounds of the interval may be accessed using the fields\n\nlo\n and \nhi\n:\n\n\njulia\n b.lo\n3.5999999999999996\n\njulia\n b.hi\n3.6\n\n\n\n\nThe diameter (length) of an interval is obtained using \ndiam(b)\n;\nfor numbers that cannot be represented exactly in base 2\n(i.e., whose \nbinary\n expansion is infinite or exceeds the current precision),\n the diameter of intervals created by \n@interval\n with a single argument corresponds to the local machine epsilon (\neps\n) in the \n:narrow\n interval-rounding mode:\n\n\njulia\n diam(b)\n4.440892098500626e-16\n\njulia\n eps(b.lo)\n4.440892098500626e-16\n\n\n\n\nStarting with v0.3, you can use additional syntax for creating intervals more easily:\nthe \n..\n operator,\n\n\njulia\n 0.1..0.3\n[0.0999999, 0.300001]\n\n\n\n\nand the \n@I_str\n string macro:\n\n\njulia\n I\n3.1\n\n[3.09999, 3.10001]\n\njulia\n I\n[3.1, 3.2]\n\n[3.09999, 3.20001]\n\n\n\n\nFrom v0.4, you can also use the \n\u00b1\n operator:\n\n\njulia\n 1.5 \u00b1 0.1\n[1.39999, 1.60001]\n\n\n\n\nArithmetic\n\n\nBasic arithmetic operations (\n+\n, \n-\n, \n*\n, \n/\n, \n^\n) are defined for pairs of intervals in a standard way (see, e.g., the book by Tucker): the result is the smallest interval containing the result of operating with each element of each interval. That is, for two intervals $X$ and $Y$ and an operation $\\circ$, we define the operation on the two intervals by\n$$X \\circ Y := { x \\circ y: x \\in X \\text{ and } y \\in Y }.$$  Again, directed rounding is used if necessary.\n\n\nFor example:\n\n\njulia\n a = @interval(0.1, 0.3)\n[0.0999999, 0.300001]\n\njulia\n b = @interval(0.3, 0.6)\n[0.299999, 0.600001]\n\njulia\n a + b\n[0.399999, 0.900001]\n\n\n\n\nHowever, subtraction of two intervals gives an initially unexpected result, due to the above definition:\n\n\njulia\n a = @interval(0, 1)\n[0, 1]\n\njulia\n a - a\n[-1, 1]\n\n\n\n\nChanging the precision\n\n\nBy default, the \n@interval\n macro creates intervals of \nFloat64\ns.\nThis may be changed globally using the \nsetprecision\n function:\n\n\njulia\n @interval 3\u03c0/2 + 1\n[5.71238, 5.71239]\n\njulia\n showall(ans)\nInterval(5.71238898038469, 5.712388980384691)\njulia\n setprecision(Interval, 256)\n256\n\njulia\n @interval 3\u03c0/2 + 1\n[5.71238, 5.71239]\u2082\u2085\u2086\n\njulia\n showall(ans)\nInterval(5.712388980384689857693965074919254326295754099062658731462416888461724609429262, 5.712388980384689857693965074919254326295754099062658731462416888461724609429401)\n\n\n\n\nThe subscript \n256\n at the end denotes the precision.\n\n\nTo change back to \nFloat64\ns, use\n\n\njulia\n setprecision(Interval, Float64)\nFloat64\n\njulia\n @interval(pi)\n[3.14159, 3.1416]\n\n\n\n\nTo check which mode is currently set, use\n\n\njulia\n precision(Interval)\n(Float64,256)\n\n\n\n\nThe result is a tuple of the type (currently \nFloat64\n or \nBigFloat\n) and the current \nBigFloat\n precision.\n\n\nNote that the \nBigFloat\n precision is set internally by \nsetprecision(Interval)\n.\nYou should \nnot\n use \nsetprecision(BigFloat)\n directly,\n\nsince the package carries out additional steps to ensure internal\nconsistency of operations involving \u03c0, in particular\ntrigonometric functions.\n\n\nElementary functions\n\n\nThe main elementary functions are implemented, for both\n\nInterval{Float64}\n and \nInterval{BigFloat}\n.\n\n\nThe functions for \nInterval{Float64}\n internally use routines from the correctly-rounded \nCRlibm\n library\n where possible, i.e. for the following functions defined in that library:\n\n\n\n\nexp\n, \nexpm1\n\n\nlog\n, \nlog1p\n, \nlog2\n, \nlog10\n\n\nsin\n, \ncos\n, \ntan\n\n\nasin\n, \nacos\n, \natan\n\n\nsinh\n, \ncosh\n\n\n\n\nOther functions that are implemented for \nInterval{Float64}\n internally convert\nto an \nInterval{BigFloat}\n, and then use routines from the \nMPFR\n library\n(\nBigFloat\n in Julia):\n\n\n\n\n^\n\n\nexp2\n, \nexp10\n\n\natan2\n, \natanh\n\n\n\n\nNote, in particular, that in order to obtain correct rounding for the power function (\n^\n),\nintervals are converted to and from \nBigFloat\n; this implies a significant slow-down in this case.\n\n\nExamples:\n\n\njulia\n a = @interval(1)\n[1, 1]\n\njulia\n sin(a)\n[0.84147, 0.841471]\n\njulia\n cos(cosh(a))\n[0.0277121, 0.0277122]\n\n\n\n\njulia\n setprecision(Interval, 53)\n53\n\njulia\n sin(@interval(1))\n[0.84147, 0.841471]\u2085\u2083\n\njulia\n @interval sin(0.1) + cos(0.2)\n[1.07989, 1.0799]\u2085\u2083\n\n\n\n\njulia\n setprecision(Interval, 128)\n128\n\njulia\n @interval sin(1)\n[0.84147, 0.841471]\u2081\u2082\u2088\n\n\n\n\nInterval rounding modes\n\n\nBy default, the directed rounding used corresponds to using the \nRoundDown\n and \nRoundUp\n rounding modes when performing calculations; this gives the narrowest resulting intervals, and is set by\n\n\nsetrounding(Interval, :narrow)\n\n\n\n\nAn alternative rounding method is to perform calculations using the (standard) \nRoundNearest\n rounding mode, and then widen the result by one machine epsilon in each direction using \nprevfloat\n and \nnextfloat\n. This is achived by\n\n\nsetrounding(Interval, :wide)\n\n\n\n\nIt generally results in wider intervals, but seems to be significantly faster.\n\n\nThe current interval rounding mode may be obtained by\n\n\nrounding(Interval)\n\n\n\n\nDisplay modes\n\n\nThere are several useful output representations for intervals, some of which we have already touched on. The display is controlled globally by the \ndisplaymode\n function, which has\nthe following options, specified by keyword arguments (type \n?displaymode\n to get help at the REPL):\n\n\n\n\n\n\nformat\n: interval output format\n\n\n\n\n\n\n:standard\n: output of the form \n[1.09999, 1.30001]\n, rounded to the current number of significant figures\n\n\n\n\n\n\n:full\n: output of the form \nInterval(1.0999999999999999, 1.3)\n, as in the \nshowall\n function\n\n\n\n\n\n\n:midpoint\n: output in the midpoint-radius form, e.g. \n1.2 \u00b1 0.100001\n\n\n\n\n\n\n\n\n\n\nsigfigs\n: number of significant figures to show in standard mode\n\n\n\n\n\n\ndecorations\n (boolean): whether to show \ndecorations\n or not\n\n\n\n\n\n\nExamples:\n\n\njulia\n a = @interval(1.1, pi)\n[1.09999, 3.1416]\n\njulia\n displaymode(sigfigs=10)\n10\n\njulia\n a\n[1.099999999, 3.141592654]\n\njulia\n displaymode(format=:full)\n\njulia\n a\nInterval(1.0999999999999999, 3.1415926535897936)\n\njulia\n displaymode(format=:midpoint)\n\njulia\n a\n2.120796327 \u00b1 1.020796327\n\njulia\n displaymode(format=:midpoint, sigfigs=4)\n4\n\njulia\n a\n2.121 \u00b1 1.021\n\njulia\n displaymode(format=:standard)\n\njulia\n a\n[1.099, 3.142]", 
            "title": "Basic usage"
        }, 
        {
            "location": "/usage/#basic-usage", 
            "text": "The basic elements of the package are  intervals , i.e. sets of real numbers (possibly including $\\pm \\infty$) of the form  $$[a, b] := { a \\le x \\le b } \\subseteq \\mathbb{R}.$$", 
            "title": "Basic usage"
        }, 
        {
            "location": "/usage/#creating-intervals", 
            "text": "Intervals are created using the  @interval  macro, which takes one or two expressions:  julia  using ValidatedNumerics\n\njulia  a = @interval(1)\n[1, 1]\n\njulia  typeof(ans)\nInterval{Float64} (constructor with 1 method)\n\njulia  b = @interval(1, 2)\n[1, 2]  These return objects of the parametrised type  Interval , the basic object in the package.\nBy default,  Interval  objects contain  Float64 s, but the library also allows using BigFloat s, for example:  julia  @biginterval(1, 2)\n[1, 2]\u2082\u2085\u2086\n\njulia  showall(ans)\nInterval(1.000000000000000000000000000000000000000000000000000000000000000000000000000000, 2.000000000000000000000000000000000000000000000000000000000000000000000000000000)  The constructor of the  Interval  type may be used directly, but this is generally not recommended, for the following reason:  julia  a = Interval(0.1, 0.3)\n[0.1, 0.3]\n\njulia  b = @interval(0.1, 0.3)\n[0.0999999, 0.300001]  What is going on here?  Due to the way floating-point arithmetic works, the interval a  created directly by the constructor turns out to contain neither the true real number 0.1, nor 0.3 .\nThe  @interval  macro, however, uses  directed rounding  to  guarantee \nthat the true 0.1 and 0.3 are included in the result.  Behind the scenes, the  @interval  macro rewrites the expression(s) passed to it, replacing the literals (0.1, 1, etc.) by calls to create correctly-rounded intervals, handled by the  convert \nfunction.  This allows us to write, for example  julia  @interval sin(0.1) + cos(0.2)\n[1.07989, 1.0799]  which is equivalent to  julia  sin(@interval(0.1)) + cos(@interval(0.2))\n[1.07989, 1.0799]  This can be used together with user-defined functions:  julia  f(x) = 2x\nf (generic function with 1 method)\n\njulia  f(@interval(0.1))\n[0.199999, 0.200001]\njulia  @interval f(0.1)\n[0.199999, 0.200001]", 
            "title": "Creating intervals"
        }, 
        {
            "location": "/usage/#pi", 
            "text": "You can create correctly-rounded intervals containing $\\pi$:  julia  @interval(pi)\n[3.14159, 3.1416]  and embed it in expressions:  julia  @interval(3*pi/2 + 1)\n[5.71238, 5.71239]\n\njulia  @interval 3\u03c0/2 + 1\n[5.71238, 5.71239]", 
            "title": "$\\pi$"
        }, 
        {
            "location": "/usage/#constructing-intervals", 
            "text": "Intervals may be constructed using rationals:  julia  @interval(1//10)\n[0.0999999, 0.100001]  Real literals are handled by internally converting them\nto rationals (using the Julia function  rationalize ). This gives\na result that contains the computer's \"best guess\" for\nthe real number the user \"had in mind\":  julia  @interval(0.1)\n[0.0999999, 0.100001]  If you instead know which exactly-representable floating-point number $a$ you need and really\nwant to make a  thin interval , i.e., an interval of the form $[a, a]$,\ncontaining precisely one float, then you can\nuse the  Interval  constructor directly:  julia  a = Interval(0.1)\n[0.1, 0.100001]\n\njulia  showall(a)\nInterval(0.1, 0.1)  Here, the  showall  function shows the internal representation of the interval,\nin a reproducible form that may be copied and pasted directly. It uses Julia's\ninternal function (which, in turn, uses the so-called Grisu algorithm) to show\nexactly as many digits are required to give an unambiguous floating-point number.  Strings may be used inside  @interval :  julia  @interval  0.1 *2\n[0.199999, 0.200001]\n\njulia  @biginterval  0.1 *2\n[0.199999, 0.200001]\u2082\u2085\u2086\n\njulia  showall(ans)\nInterval(1.999999999999999999999999999999999999999999999999999999999999999999999999999983e-01, 2.000000000000000000000000000000000000000000000000000000000000000000000000000004e-01)  Strings in the form of intervals may also be used:  julia  @interval  [1.2, 3.4] \n[1.19999, 3.40001]  Intervals can be created from variables:  julia  a = 3.6\n3.6\n\njulia  b = @interval(a)\n[3.59999, 3.60001]  The upper and lower bounds of the interval may be accessed using the fields lo  and  hi :  julia  b.lo\n3.5999999999999996\n\njulia  b.hi\n3.6  The diameter (length) of an interval is obtained using  diam(b) ;\nfor numbers that cannot be represented exactly in base 2\n(i.e., whose  binary  expansion is infinite or exceeds the current precision),\n the diameter of intervals created by  @interval  with a single argument corresponds to the local machine epsilon ( eps ) in the  :narrow  interval-rounding mode:  julia  diam(b)\n4.440892098500626e-16\n\njulia  eps(b.lo)\n4.440892098500626e-16  Starting with v0.3, you can use additional syntax for creating intervals more easily:\nthe  ..  operator,  julia  0.1..0.3\n[0.0999999, 0.300001]  and the  @I_str  string macro:  julia  I 3.1 \n[3.09999, 3.10001]\n\njulia  I [3.1, 3.2] \n[3.09999, 3.20001]  From v0.4, you can also use the  \u00b1  operator:  julia  1.5 \u00b1 0.1\n[1.39999, 1.60001]", 
            "title": "Constructing intervals"
        }, 
        {
            "location": "/usage/#arithmetic", 
            "text": "Basic arithmetic operations ( + ,  - ,  * ,  / ,  ^ ) are defined for pairs of intervals in a standard way (see, e.g., the book by Tucker): the result is the smallest interval containing the result of operating with each element of each interval. That is, for two intervals $X$ and $Y$ and an operation $\\circ$, we define the operation on the two intervals by\n$$X \\circ Y := { x \\circ y: x \\in X \\text{ and } y \\in Y }.$$  Again, directed rounding is used if necessary.  For example:  julia  a = @interval(0.1, 0.3)\n[0.0999999, 0.300001]\n\njulia  b = @interval(0.3, 0.6)\n[0.299999, 0.600001]\n\njulia  a + b\n[0.399999, 0.900001]  However, subtraction of two intervals gives an initially unexpected result, due to the above definition:  julia  a = @interval(0, 1)\n[0, 1]\n\njulia  a - a\n[-1, 1]", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/usage/#changing-the-precision", 
            "text": "By default, the  @interval  macro creates intervals of  Float64 s.\nThis may be changed globally using the  setprecision  function:  julia  @interval 3\u03c0/2 + 1\n[5.71238, 5.71239]\n\njulia  showall(ans)\nInterval(5.71238898038469, 5.712388980384691)\njulia  setprecision(Interval, 256)\n256\n\njulia  @interval 3\u03c0/2 + 1\n[5.71238, 5.71239]\u2082\u2085\u2086\n\njulia  showall(ans)\nInterval(5.712388980384689857693965074919254326295754099062658731462416888461724609429262, 5.712388980384689857693965074919254326295754099062658731462416888461724609429401)  The subscript  256  at the end denotes the precision.  To change back to  Float64 s, use  julia  setprecision(Interval, Float64)\nFloat64\n\njulia  @interval(pi)\n[3.14159, 3.1416]  To check which mode is currently set, use  julia  precision(Interval)\n(Float64,256)  The result is a tuple of the type (currently  Float64  or  BigFloat ) and the current  BigFloat  precision.  Note that the  BigFloat  precision is set internally by  setprecision(Interval) .\nYou should  not  use  setprecision(BigFloat)  directly, \nsince the package carries out additional steps to ensure internal\nconsistency of operations involving \u03c0, in particular\ntrigonometric functions.", 
            "title": "Changing the precision"
        }, 
        {
            "location": "/usage/#elementary-functions", 
            "text": "The main elementary functions are implemented, for both Interval{Float64}  and  Interval{BigFloat} .  The functions for  Interval{Float64}  internally use routines from the correctly-rounded  CRlibm  library  where possible, i.e. for the following functions defined in that library:   exp ,  expm1  log ,  log1p ,  log2 ,  log10  sin ,  cos ,  tan  asin ,  acos ,  atan  sinh ,  cosh   Other functions that are implemented for  Interval{Float64}  internally convert\nto an  Interval{BigFloat} , and then use routines from the  MPFR  library\n( BigFloat  in Julia):   ^  exp2 ,  exp10  atan2 ,  atanh   Note, in particular, that in order to obtain correct rounding for the power function ( ^ ),\nintervals are converted to and from  BigFloat ; this implies a significant slow-down in this case.  Examples:  julia  a = @interval(1)\n[1, 1]\n\njulia  sin(a)\n[0.84147, 0.841471]\n\njulia  cos(cosh(a))\n[0.0277121, 0.0277122]  julia  setprecision(Interval, 53)\n53\n\njulia  sin(@interval(1))\n[0.84147, 0.841471]\u2085\u2083\n\njulia  @interval sin(0.1) + cos(0.2)\n[1.07989, 1.0799]\u2085\u2083  julia  setprecision(Interval, 128)\n128\n\njulia  @interval sin(1)\n[0.84147, 0.841471]\u2081\u2082\u2088", 
            "title": "Elementary functions"
        }, 
        {
            "location": "/usage/#interval-rounding-modes", 
            "text": "By default, the directed rounding used corresponds to using the  RoundDown  and  RoundUp  rounding modes when performing calculations; this gives the narrowest resulting intervals, and is set by  setrounding(Interval, :narrow)  An alternative rounding method is to perform calculations using the (standard)  RoundNearest  rounding mode, and then widen the result by one machine epsilon in each direction using  prevfloat  and  nextfloat . This is achived by  setrounding(Interval, :wide)  It generally results in wider intervals, but seems to be significantly faster.  The current interval rounding mode may be obtained by  rounding(Interval)", 
            "title": "Interval rounding modes"
        }, 
        {
            "location": "/usage/#display-modes", 
            "text": "There are several useful output representations for intervals, some of which we have already touched on. The display is controlled globally by the  displaymode  function, which has\nthe following options, specified by keyword arguments (type  ?displaymode  to get help at the REPL):    format : interval output format    :standard : output of the form  [1.09999, 1.30001] , rounded to the current number of significant figures    :full : output of the form  Interval(1.0999999999999999, 1.3) , as in the  showall  function    :midpoint : output in the midpoint-radius form, e.g.  1.2 \u00b1 0.100001      sigfigs : number of significant figures to show in standard mode    decorations  (boolean): whether to show  decorations  or not", 
            "title": "Display modes"
        }, 
        {
            "location": "/usage/#examples", 
            "text": "julia  a = @interval(1.1, pi)\n[1.09999, 3.1416]\n\njulia  displaymode(sigfigs=10)\n10\n\njulia  a\n[1.099999999, 3.141592654]\n\njulia  displaymode(format=:full)\n\njulia  a\nInterval(1.0999999999999999, 3.1415926535897936)\n\njulia  displaymode(format=:midpoint)\n\njulia  a\n2.120796327 \u00b1 1.020796327\n\njulia  displaymode(format=:midpoint, sigfigs=4)\n4\n\njulia  a\n2.121 \u00b1 1.021\n\njulia  displaymode(format=:standard)\n\njulia  a\n[1.099, 3.142]", 
            "title": "Examples:"
        }, 
        {
            "location": "/multidim/", 
            "text": "Multi-dimensional boxes\n\n\nStarting with v0.3, multi-dimensional (hyper-)boxes are implemented in the\n\nIntervalBox\n type.\nThese represent Cartesian products of intervals, i.e. rectangles (in 2D),\ncuboids (in 3D), etc.\n\n\nIntervalBox\nes are constructed from an array of \nInterval\ns; it is\noften convenient to use the \n..\n notation:\n\n\njulia\n X = IntervalBox(1..3, 2..4)\n[1, 3] \u00d7 [2, 4]\n\njulia\n Y = IntervalBox(2.1..2.9, 3.1..4.9)\n[2.09999, 2.90001] \u00d7 [3.09999, 4.90001]\n\n\n\n\nSeveral operations are defined on \nIntervalBox\nes, for example:\n\n\njulia\n X \u2229 Y\n[2.09999, 2.90001] \u00d7 [3.09999, 4]\n\njulia\n X \u2286 Y\nfalse\n\n\n\n\nTo facilitate working with \nIntervalBox\nes, a macro \n@intervalbox\n is defined.\nGiven a multi-dimensional function taking several inputs, this creates both the original form and a\nversion that works with a single \nIntervalBox\n argument, e.g.\n\n\njulia\n @intervalbox f(x, y) = (x + y, x - y)\nf (generic function with 2 methods)\n\njulia\n f(1..1, 2..2)  \n([3.0, 3.0],[-1.0, -1.0])\n\njulia\n X = IntervalBox(1..1, 2..2)\n[1.0, 1.0] \u00d7 [2.0, 2.0]\n\njulia\n f(X)\n[3.0, 3.0] \u00d7 [-1.0, -1.0]\n\n\n\n\nThe first version takes a tuple of \nInterval\ns and returns another tuple of \nInterval\ns;\nthe second version takes a single \nIntervalBox\n and automatically does the\nnecessary unpacking and packing to return an \nIntervalBox.", 
            "title": "Multi-dimensional"
        }, 
        {
            "location": "/multidim/#multi-dimensional-boxes", 
            "text": "Starting with v0.3, multi-dimensional (hyper-)boxes are implemented in the IntervalBox  type.\nThese represent Cartesian products of intervals, i.e. rectangles (in 2D),\ncuboids (in 3D), etc.  IntervalBox es are constructed from an array of  Interval s; it is\noften convenient to use the  ..  notation:  julia  X = IntervalBox(1..3, 2..4)\n[1, 3] \u00d7 [2, 4]\n\njulia  Y = IntervalBox(2.1..2.9, 3.1..4.9)\n[2.09999, 2.90001] \u00d7 [3.09999, 4.90001]  Several operations are defined on  IntervalBox es, for example:  julia  X \u2229 Y\n[2.09999, 2.90001] \u00d7 [3.09999, 4]\n\njulia  X \u2286 Y\nfalse  To facilitate working with  IntervalBox es, a macro  @intervalbox  is defined.\nGiven a multi-dimensional function taking several inputs, this creates both the original form and a\nversion that works with a single  IntervalBox  argument, e.g.  julia  @intervalbox f(x, y) = (x + y, x - y)\nf (generic function with 2 methods)\n\njulia  f(1..1, 2..2)  \n([3.0, 3.0],[-1.0, -1.0])\n\njulia  X = IntervalBox(1..1, 2..2)\n[1.0, 1.0] \u00d7 [2.0, 2.0]\n\njulia  f(X)\n[3.0, 3.0] \u00d7 [-1.0, -1.0]  The first version takes a tuple of  Interval s and returns another tuple of  Interval s;\nthe second version takes a single  IntervalBox  and automatically does the\nnecessary unpacking and packing to return an  IntervalBox.", 
            "title": "Multi-dimensional boxes"
        }, 
        {
            "location": "/root_finding/", 
            "text": "MathJax.Hub.Config({\n    TeX: { equationNumbers: { autoNumber: \"AMS\" } }\n  });\n  MathJax.Hub.Config({\n    TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\", \"autobold.js\", \"autoload-all.js\"] }\n  });\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n      processEscapes: true\n    }\n  });\n\n\n\n\n\n\n\n\n\nRoot finding\n\n\nInterval arithmetic not only provides guaranteed numerical calculations; it also\nmakes possible fundamentally new algorithms.\n\n\nInterval Newton method\n\n\nOne such algorithm is the \ninterval Newton method\n. This is a version of the\nstandard Newton (or Newton-Raphson) algorithm, an iterative method for finding\nroots (zeros) of functions.\nThe interval version, however, is fundamentally different from its standard\ncounterpart, in that it can (under the best circumstances) provide rigorous\n\nguarantees\n about the presence or absence and uniqueness of roots of a given\nfunction in a given interval, and tells us explicitly when it is unable to\nprovide such a guarantee.\n\n\nThe idea of the Newton method is to calculate a root $x^\\ast$ of a function\n$f$ [i.e., a value such that $f(x^*) = 0$] from an initial guess $x$ using\n\n\n$$x^* = x - \\frac{f(x)}{f'(\\xi)},$$\n\n\nfor some $\\xi$ between $x$ and $x^*$. Since $\\xi$ is unknown, we can bound it as\n\n\n$$f'(\\xi) \\in F'(X),$$\n\n\nwhere $X$ is a containing interval and $F'(X)$ denotes the \ninterval extension\n\nof the function $f$, consisting of applying the same operations as the function\n$f$ to the interval $X$.\n\n\nWe define an \ninterval Newton operator\n $\\mathcal{N}$ as follows:\n\n\n$$\\mathcal{N}(X) := m(X) - \\frac{F(m(X))}{F'(X)},$$\n\n\nwhere $m(X)$  is the midpoint of $X$ converted into an interval.\n\n\nIt turns out that $\\mathcal{N}$ tells us precisely whether there is a root of $f$ in\nthe interval $X$: there is no root if $\\mathcal{N}(X) \\cap X = \\emptyset$, and there is\na unique root if $\\mathcal{N}(X) \\subseteq X$.\nThere is also an extension to intervals in which the derivative $F'(X)$ contains $0$,\nin which case the Newton operator returns a union of two intervals.\n\n\nIterating the Newton operator on the resulting sets gives a rigorous algorithm\nthat is \nguaranteed to find all roots\n of a\nreal function in a given interval (or to inform us if it is unable to do so,\nfor example at a multiple root); see Tucker's book for more details.\n\n\nUsage of the interval Newton method\n\n\nThe interval Newton method is implemented for real functions of a single\nvariable as the function \nnewton\n. For example, we can calculate rigorously the square roots of 2:\n\n\njulia\n using ValidatedNumerics\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\n\n\n\nThe function \nnewton\n  is passed the function and the interval in which to search for roots;\nit returns an array of \nRoot\n objects, that contain the interval where a root is found,\ntogether with a symbol \n:unique\n if there is guaranteed to be a unique root in that\ninterval, or \n:unknown\n if the Newton method is unable to make a guarantee, for example,\nwhen there is a double root:\n\n\njulia\n newton(f, @interval(-5,5))\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([2.0, 2.0], :unique)\n\n\n\n\nThe Newton method may be applied directly to a vector of known roots,\nfor example to refine them with higher precision:\n\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n roots = newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\njulia\n setprecision(Interval, 256)\n256\n\njulia\n newton(f, roots)\n2-element Array{ValidatedNumerics.Root{Base.MPFR.BigFloat},1}:\n Root([-1.414213562373095048801688724209698078569671875376948073176679737990732478462119, -1.414213562373095048801688724209698078569671875376948073176679737990732478462102]\u2082\u2085\u2086, :unique)\n Root([1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1.414213562373095048801688724209698078569671875376948073176679737990732478462119]\u2082\u2085\u2086, :unique)\n\njulia\n abs(roots2[2].interval.lo - sqrt(big(2)))\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n\n\n\n\nKrawczyk method\n\n\nAn alternative method is the \nKrawczyk method\n, implemented in the function\n\nkrawczyk\n, with the same interface as the Newton method:\n\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n krawczyk(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730954, -1.4142135623730947], :unique)\n Root([1.4142135623730947, 1.4142135623730954], :unique)\n\njulia\n newton(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\n\n\n\nThe Krawczyk method really comes into its own for higher-dimensional functions;\nthis is planned to be implemented in the future.\n\n\nfind_roots\n interface\n\n\nAutomatic differentiation is used to calculate the derivative used in the Newton method\nif the derivative function is not given explicitly as the second argument to \nnewton\n.\n\n\nAn interface \nfind_roots\n is provided, which does not require an interval to be passed:\n\n\njulia\n find_roots(f, -5, 5)\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([1.9999999999999998, 2.0000000000000004], :unique)\n\n\n\n\nThere is also a version \nfind_roots_midpoint\n that returns three vectors:\nthe midpoint of each interval; the radius of the interval; and the symbol.\nThis may be useful for someone who just wishes to find roots of a function,\nwithout wanting to understand how to manipulate interval objects:\n\n\njulia\n find_roots_midpoint(f, -5, 5)\n([-1.4142135623730951,1.414213562373095],[2.220446049250313e-16,4.440892098500626e-16],[:unique,:unique])\n\n\n\n\nThis uses the function \nmidpoint_radius\n, that returns the midpoint and radius\nof a given interval:\n\n\njulia\n a = @interval(0.1, 0.2)\n[0.09999999999999999, 0.2]\n\njulia\n midpoint_radius(a)\n(0.15,0.05000000000000002)", 
            "title": "Root finding"
        }, 
        {
            "location": "/root_finding/#root-finding", 
            "text": "Interval arithmetic not only provides guaranteed numerical calculations; it also\nmakes possible fundamentally new algorithms.", 
            "title": "Root finding"
        }, 
        {
            "location": "/root_finding/#interval-newton-method", 
            "text": "One such algorithm is the  interval Newton method . This is a version of the\nstandard Newton (or Newton-Raphson) algorithm, an iterative method for finding\nroots (zeros) of functions.\nThe interval version, however, is fundamentally different from its standard\ncounterpart, in that it can (under the best circumstances) provide rigorous guarantees  about the presence or absence and uniqueness of roots of a given\nfunction in a given interval, and tells us explicitly when it is unable to\nprovide such a guarantee.  The idea of the Newton method is to calculate a root $x^\\ast$ of a function\n$f$ [i.e., a value such that $f(x^*) = 0$] from an initial guess $x$ using  $$x^* = x - \\frac{f(x)}{f'(\\xi)},$$  for some $\\xi$ between $x$ and $x^*$. Since $\\xi$ is unknown, we can bound it as  $$f'(\\xi) \\in F'(X),$$  where $X$ is a containing interval and $F'(X)$ denotes the  interval extension \nof the function $f$, consisting of applying the same operations as the function\n$f$ to the interval $X$.  We define an  interval Newton operator  $\\mathcal{N}$ as follows:  $$\\mathcal{N}(X) := m(X) - \\frac{F(m(X))}{F'(X)},$$  where $m(X)$  is the midpoint of $X$ converted into an interval.  It turns out that $\\mathcal{N}$ tells us precisely whether there is a root of $f$ in\nthe interval $X$: there is no root if $\\mathcal{N}(X) \\cap X = \\emptyset$, and there is\na unique root if $\\mathcal{N}(X) \\subseteq X$.\nThere is also an extension to intervals in which the derivative $F'(X)$ contains $0$,\nin which case the Newton operator returns a union of two intervals.  Iterating the Newton operator on the resulting sets gives a rigorous algorithm\nthat is  guaranteed to find all roots  of a\nreal function in a given interval (or to inform us if it is unable to do so,\nfor example at a multiple root); see Tucker's book for more details.", 
            "title": "Interval Newton method"
        }, 
        {
            "location": "/root_finding/#usage-of-the-interval-newton-method", 
            "text": "The interval Newton method is implemented for real functions of a single\nvariable as the function  newton . For example, we can calculate rigorously the square roots of 2:  julia  using ValidatedNumerics\n\njulia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)  The function  newton   is passed the function and the interval in which to search for roots;\nit returns an array of  Root  objects, that contain the interval where a root is found,\ntogether with a symbol  :unique  if there is guaranteed to be a unique root in that\ninterval, or  :unknown  if the Newton method is unable to make a guarantee, for example,\nwhen there is a double root:  julia  newton(f, @interval(-5,5))\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([2.0, 2.0], :unique)  The Newton method may be applied directly to a vector of known roots,\nfor example to refine them with higher precision:  julia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  roots = newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\njulia  setprecision(Interval, 256)\n256\n\njulia  newton(f, roots)\n2-element Array{ValidatedNumerics.Root{Base.MPFR.BigFloat},1}:\n Root([-1.414213562373095048801688724209698078569671875376948073176679737990732478462119, -1.414213562373095048801688724209698078569671875376948073176679737990732478462102]\u2082\u2085\u2086, :unique)\n Root([1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1.414213562373095048801688724209698078569671875376948073176679737990732478462119]\u2082\u2085\u2086, :unique)\n\njulia  abs(roots2[2].interval.lo - sqrt(big(2)))\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000", 
            "title": "Usage of the interval Newton method"
        }, 
        {
            "location": "/root_finding/#krawczyk-method", 
            "text": "An alternative method is the  Krawczyk method , implemented in the function krawczyk , with the same interface as the Newton method:  julia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  krawczyk(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730954, -1.4142135623730947], :unique)\n Root([1.4142135623730947, 1.4142135623730954], :unique)\n\njulia  newton(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)  The Krawczyk method really comes into its own for higher-dimensional functions;\nthis is planned to be implemented in the future.", 
            "title": "Krawczyk method"
        }, 
        {
            "location": "/root_finding/#find_roots-interface", 
            "text": "Automatic differentiation is used to calculate the derivative used in the Newton method\nif the derivative function is not given explicitly as the second argument to  newton .  An interface  find_roots  is provided, which does not require an interval to be passed:  julia  find_roots(f, -5, 5)\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([1.9999999999999998, 2.0000000000000004], :unique)  There is also a version  find_roots_midpoint  that returns three vectors:\nthe midpoint of each interval; the radius of the interval; and the symbol.\nThis may be useful for someone who just wishes to find roots of a function,\nwithout wanting to understand how to manipulate interval objects:  julia  find_roots_midpoint(f, -5, 5)\n([-1.4142135623730951,1.414213562373095],[2.220446049250313e-16,4.440892098500626e-16],[:unique,:unique])  This uses the function  midpoint_radius , that returns the midpoint and radius\nof a given interval:  julia  a = @interval(0.1, 0.2)\n[0.09999999999999999, 0.2]\n\njulia  midpoint_radius(a)\n(0.15,0.05000000000000002)", 
            "title": "find_roots interface"
        }, 
        {
            "location": "/rounding/", 
            "text": "Why is rounding necessary?\n\n\nWhat happens when we write the following Julia code?\n\n\njulia\n x = 0.1\n0.1\n\n\n\n\nThis appears to store the value \n0.1\n in a variable \nx\n of type \nFloat64\n.\nIn fact, however, it stores a \nslightly different\n number, since \n0.1\n \ncannot be represented exactly in binary floating point arithmetic, at any precision\n.\n\n\nThe true value that is actually stored in the variable can be conveniently determined in Julia using arbitrary-precision arithmetic with \nBigFloat\ns:\n\n\njulia\n big(0.1)\n1.000000000000000055511151231257827021181583404541015625000000000000000000000000e-01\n\n\n\n\nSo, in fact, the Julia float \n0.1\n refers to a real number that is slightly greater than 0.1. By default, such calculations are done in round-to-nearest mode (\nRoundNearest\n); i.e., the nearest representable floating-point number to 0.1 is used.\n\n\n[Recall that to get a \nBigFloat\n that is as close as possible to the true 0.1, you can use a special string macro:\n\n\njulia\n big\n0.1\n\n1.000000000000000000000000000000000000000000000000000000000000000000000000000002e-01\n\n\n\n\n]\n\n\nSuppose that we create a thin interval, containing just the floating-point number \n0.1\n:\n\n\njulia\n II = Interval(0.1)\n[0.1, 0.100001]\n\njulia\n showall(II)\nInterval(0.1, 0.1)\n\n\n\n\nIt looks like \nII\n contains (the true) 0.1, but from the above discussion we see that \nit does not\n. In order to contain 0.1, the end-points of the interval must be rounded outwards (\"directed rounding\"): the lower bound is rounded down, and the upper bound is rounded up.\n\n\nThis rounding is handled by the \n@interval\n  macro, which generates correctly-rounded intervals:\n\n\njulia\n a = @interval(0.1)\n[0.0999999, 0.100001]\n\n\n\n\nThe true 0.1 is now correctly contained in the intervals, so that any calculations on these intervals will contain the true result of calculating with 0.1. For example, if we define\n\n\njulia\n f(x) = 2x + 0.2\n\n\n\n\nthen we can apply the function \nf\n to the interval \na\n to obtain\n\n\njulia\n f(a)\n[0.399999, 0.400001]\n\njulia\n showall(f(a))\nInterval(0.39999999999999997, 0.4)\n\n\n\n\nThe result correctly contains the true 0.4.\n\n\nMore detail: the internal representation\n\n\nLet's look at the internal representation of the \nFloat64\n number 0.1:\n\n\njulia\n bits(0.1)\n\n0011111110111001100110011001100110011001100110011001100110011010\n\n\n\n\n\nThe last 53 bits of these 64 bits correspond to the binary expansion of 0.1, which is\n\n\n0.000110011001100110011001100110011001100...\n\n\n\n\nWe see that the expansion is periodic; in fact, the binary expansion of 0.1 has an infinite repetition of the sequence of digits \n1100\n. It is thus \nimpossible\n to represent the decimal 0.1 in binary, with \nany\n precision.\n\n\nThe true value must be approximated by a floating-point number with fixed precision -- this procedure is called \nrounding\n. For positive numbers, rounding down may be accomplished simply by truncating the expansion; rounding up is accomplished by incrementing the final binary digit and propagating any resulting changes.", 
            "title": "Rounding"
        }, 
        {
            "location": "/rounding/#why-is-rounding-necessary", 
            "text": "What happens when we write the following Julia code?  julia  x = 0.1\n0.1  This appears to store the value  0.1  in a variable  x  of type  Float64 .\nIn fact, however, it stores a  slightly different  number, since  0.1   cannot be represented exactly in binary floating point arithmetic, at any precision .  The true value that is actually stored in the variable can be conveniently determined in Julia using arbitrary-precision arithmetic with  BigFloat s:  julia  big(0.1)\n1.000000000000000055511151231257827021181583404541015625000000000000000000000000e-01  So, in fact, the Julia float  0.1  refers to a real number that is slightly greater than 0.1. By default, such calculations are done in round-to-nearest mode ( RoundNearest ); i.e., the nearest representable floating-point number to 0.1 is used.  [Recall that to get a  BigFloat  that is as close as possible to the true 0.1, you can use a special string macro:  julia  big 0.1 \n1.000000000000000000000000000000000000000000000000000000000000000000000000000002e-01  ]  Suppose that we create a thin interval, containing just the floating-point number  0.1 :  julia  II = Interval(0.1)\n[0.1, 0.100001]\n\njulia  showall(II)\nInterval(0.1, 0.1)  It looks like  II  contains (the true) 0.1, but from the above discussion we see that  it does not . In order to contain 0.1, the end-points of the interval must be rounded outwards (\"directed rounding\"): the lower bound is rounded down, and the upper bound is rounded up.  This rounding is handled by the  @interval   macro, which generates correctly-rounded intervals:  julia  a = @interval(0.1)\n[0.0999999, 0.100001]  The true 0.1 is now correctly contained in the intervals, so that any calculations on these intervals will contain the true result of calculating with 0.1. For example, if we define  julia  f(x) = 2x + 0.2  then we can apply the function  f  to the interval  a  to obtain  julia  f(a)\n[0.399999, 0.400001]\n\njulia  showall(f(a))\nInterval(0.39999999999999997, 0.4)  The result correctly contains the true 0.4.", 
            "title": "Why is rounding necessary?"
        }, 
        {
            "location": "/rounding/#more-detail-the-internal-representation", 
            "text": "Let's look at the internal representation of the  Float64  number 0.1:  julia  bits(0.1) 0011111110111001100110011001100110011001100110011001100110011010   The last 53 bits of these 64 bits correspond to the binary expansion of 0.1, which is  0.000110011001100110011001100110011001100...  We see that the expansion is periodic; in fact, the binary expansion of 0.1 has an infinite repetition of the sequence of digits  1100 . It is thus  impossible  to represent the decimal 0.1 in binary, with  any  precision.  The true value must be approximated by a floating-point number with fixed precision -- this procedure is called  rounding . For positive numbers, rounding down may be accomplished simply by truncating the expansion; rounding up is accomplished by incrementing the final binary digit and propagating any resulting changes.", 
            "title": "More detail: the internal representation"
        }, 
        {
            "location": "/decorations/", 
            "text": "[I 160508 10:04:49 handlers:132] Browser Connected: http://127.0.0.1:8000/multid\n\n  MathJax.Hub.Config({\n    TeX: { equationNumbers: { autoNumber: \"AMS\" } }\n  });\n  MathJax.Hub.Config({\n    TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\", \"autobold.js\", \"autoload-all.js\"] }\n  });\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [['$','$']],\n      processEscapes: true\n    }\n  });\n\n\n\n\n\n\n\nDecorations\n\n\nDecorations are flags, or labels, attached to intervals to indicate the status of a given interval as the result of evaluating a function on an initial interval. The combination of an interval $X$ and a decoration $d$ is called a decorated interval.\n\n\nThe allowed decorations and their ordering are as follows:\n\ncom\n \n \ndac\n \n \ndef\n \n \ntrv\n \n \nill\n.\n\n\nSuppose that a decorated interval $(X, d)$ is the result of evaluating a function $f$, or the composition of a sequence of functions, on an initial decorated interval $(X_0, d_0)$. The meaning of the resulting decoration $d$ is as follows:\n\n\n\n\n\n\ncom\n (\"common\"): $X$ is a closed, bounded, nonempty subset of the domain of $f$; $f$ is continuous on the interval $X$; and the resulting interval $f(X)$ is bounded.\n\n\n\n\n\n\ndac\n (\"defined \n continuous\"): $X$ is a nonempty subset of $\\mathrm{Dom}(f)$, and $f$ is continuous on $X$.\n\n\n\n\n\n\ndef\n (\"defined\"): $X$ is a nonempty subset of $\\mathrm{Dom}(f)$, i.e. $f$ is defined at each point of $X$.\n\n\n\n\n\n\ntrv\n (\"trivial\"): always true; gives no information\n\n\n\n\n\n\nill\n (\"ill-formed\"): Not an Interval (an error occurred), e.g. $\\mathrm{Dom}(f) = \\emptyset$.\n\n\n\n\n\n\nAn example will be given at the end of this section.\n\n\nInitialisation\n\n\nThe simplest way to create a \nDecoratedInterval\n is with the \n@decorated\n macro,\nwhich does correct rounding:\n\n\njulia\n @decorated(0.1, 0.3)\n[0.0999999, 0.300001]\n\n\n\n\nThe \nDecoratedInterval\n constructor may also be used if necessary:\n\n\njulia\n X = DecoratedInterval(3, 4)\n[3, 4]\n\n\n\n\nBy default, decorations are not displayed. The following turns on display of decorations:\n\n\njulia\n displaymode(decorations=true)\n\njulia\n X\n[3, 4]_com\n\n\n\n\nIf no decoration is explicitly specified when a \nDecoratedInterval\n is created, then it is initialised with a decoration according to its interval \nX\n:\n\n\n\n\ncom\n: if \nX\n is nonempty and bounded;\n\n\ndac\n if \nX\n is unbounded;\n\n\ntrv\n if \nX\n is empty.\n\n\n\n\nAn explicit decoration may be provided for advanced use:\n\n\njulia\n DecoratedInterval(3, 4, dac)\n[3, 4]_dac\n\njulia\n DecoratedInterval(X, def)\n[3, 4]_def\n\n\n\n\nHere, a new \nDecoratedInterval\n was created by extracting the interval from another one and appending a different decoration.\n\n\nAction of functions\n\n\nA decoration is the combination of an interval together with the sequence of functions that it has passed through. Here are some examples:\n\n\njulia\n X1 = @decorated(0.5, 3)\n[0.5, 3]_com\n\njulia\n sqrt(X1)\n[0.707106, 1.73206]_com\n\n\n\n\nIn this case, both input and output are \"common\" intervals, meaning that they are closed and bounded, and that the resulting function is continuous over the input interval, so that fixed-point theorems may be applied. Since \nsqrt(X1) \u2286 X1\n, we know that there must be a fixed point of the function inside the interval \nX1\n (in this case, \nsqrt(1) == 1\n).\n\n\njulia\n X2 = DecoratedInterval(3, \u221e)\n[3, \u221e]_dac\n\njulia\n sqrt(X2)\n[1.73205, \u221e]_dac\n\n\n\n\nSince the intervals are unbounded here, the maximum decoration possible is \ndac\n.\n\n\njulia\n X3 = @decorated(-3, 4)\n[-3, 4]_com\n\njulia\n sign(X3)\n[-1, 1]_def\n\n\n\n\nThe \nsign\n function is discontinuous at 0, but is defined everywhere on the input interval, so the decoration is \ndef\n.\n\n\njulia\n X4 = @decorated(-3.5, 4.1)\n[-3.5, 4.10001]_com\n\njulia\n sqrt(X4)\n[0, 2.02485]_trv\n\n\n\n\nThe negative part of \nX\n is discarded by the \nsqrt\n function, since its domain is \n[0,\u221e]\n. (This process of discarding parts of the input interval that are not in the domain is called \"loose evaluation\".) The fact that this occurred is, however, recorded by the resulting decoration, \ntrv\n, indicating a loss of information: \"nothing is known\" about the relationship between the output interval and the input.\n\n\nIn this case, we know why the decoration was reduced to \ntrv\n. But if this were just a single step in a longer calculation, a resulting \ntrv\n decoration shows only that something like this happened \nat some step\n. For example:\n\n\njulia\n X5 = @decorated(-3, 3)\n[-3, 3]_com\n\njulia\n asin(sqrt(X5))\n[0, 1.5708]_trv\n\njulia\n X6 = @decorated(0, 3)\n[0, 3]_com\n\njulia\n asin(sqrt(X6))\n[0, 1.5708]_trv\n\n\n\n\nIn both cases, \nasin(sqrt(X))\n gives a result with a \ntrv\n decoration, but\nwe do not know at which step this happened, unless we break down the function into its constituent parts:\n\n\njulia\n sqrt(X5)\n[0, 1.73206]_trv\n\njulia\n sqrt(X6)\n[0, 1.73206]_com\n\n\n\n\nThis shows that loose evaluation occurred in different parts of the expression in the two different cases.\n\n\nIn general, the \ntrv\n decoration is thus used only to signal that \"something unexpected\" happened during the calculation. Often this is later used to split up the original interval into pieces and reevaluate the function on each piece to refine the information that is obtained about the function.", 
            "title": "Decorations"
        }, 
        {
            "location": "/decorations/#decorations", 
            "text": "Decorations are flags, or labels, attached to intervals to indicate the status of a given interval as the result of evaluating a function on an initial interval. The combination of an interval $X$ and a decoration $d$ is called a decorated interval.  The allowed decorations and their ordering are as follows: com     dac     def     trv     ill .  Suppose that a decorated interval $(X, d)$ is the result of evaluating a function $f$, or the composition of a sequence of functions, on an initial decorated interval $(X_0, d_0)$. The meaning of the resulting decoration $d$ is as follows:    com  (\"common\"): $X$ is a closed, bounded, nonempty subset of the domain of $f$; $f$ is continuous on the interval $X$; and the resulting interval $f(X)$ is bounded.    dac  (\"defined   continuous\"): $X$ is a nonempty subset of $\\mathrm{Dom}(f)$, and $f$ is continuous on $X$.    def  (\"defined\"): $X$ is a nonempty subset of $\\mathrm{Dom}(f)$, i.e. $f$ is defined at each point of $X$.    trv  (\"trivial\"): always true; gives no information    ill  (\"ill-formed\"): Not an Interval (an error occurred), e.g. $\\mathrm{Dom}(f) = \\emptyset$.    An example will be given at the end of this section.", 
            "title": "Decorations"
        }, 
        {
            "location": "/decorations/#initialisation", 
            "text": "The simplest way to create a  DecoratedInterval  is with the  @decorated  macro,\nwhich does correct rounding:  julia  @decorated(0.1, 0.3)\n[0.0999999, 0.300001]  The  DecoratedInterval  constructor may also be used if necessary:  julia  X = DecoratedInterval(3, 4)\n[3, 4]  By default, decorations are not displayed. The following turns on display of decorations:  julia  displaymode(decorations=true)\n\njulia  X\n[3, 4]_com  If no decoration is explicitly specified when a  DecoratedInterval  is created, then it is initialised with a decoration according to its interval  X :   com : if  X  is nonempty and bounded;  dac  if  X  is unbounded;  trv  if  X  is empty.   An explicit decoration may be provided for advanced use:  julia  DecoratedInterval(3, 4, dac)\n[3, 4]_dac\n\njulia  DecoratedInterval(X, def)\n[3, 4]_def  Here, a new  DecoratedInterval  was created by extracting the interval from another one and appending a different decoration.", 
            "title": "Initialisation"
        }, 
        {
            "location": "/decorations/#action-of-functions", 
            "text": "A decoration is the combination of an interval together with the sequence of functions that it has passed through. Here are some examples:  julia  X1 = @decorated(0.5, 3)\n[0.5, 3]_com\n\njulia  sqrt(X1)\n[0.707106, 1.73206]_com  In this case, both input and output are \"common\" intervals, meaning that they are closed and bounded, and that the resulting function is continuous over the input interval, so that fixed-point theorems may be applied. Since  sqrt(X1) \u2286 X1 , we know that there must be a fixed point of the function inside the interval  X1  (in this case,  sqrt(1) == 1 ).  julia  X2 = DecoratedInterval(3, \u221e)\n[3, \u221e]_dac\n\njulia  sqrt(X2)\n[1.73205, \u221e]_dac  Since the intervals are unbounded here, the maximum decoration possible is  dac .  julia  X3 = @decorated(-3, 4)\n[-3, 4]_com\n\njulia  sign(X3)\n[-1, 1]_def  The  sign  function is discontinuous at 0, but is defined everywhere on the input interval, so the decoration is  def .  julia  X4 = @decorated(-3.5, 4.1)\n[-3.5, 4.10001]_com\n\njulia  sqrt(X4)\n[0, 2.02485]_trv  The negative part of  X  is discarded by the  sqrt  function, since its domain is  [0,\u221e] . (This process of discarding parts of the input interval that are not in the domain is called \"loose evaluation\".) The fact that this occurred is, however, recorded by the resulting decoration,  trv , indicating a loss of information: \"nothing is known\" about the relationship between the output interval and the input.  In this case, we know why the decoration was reduced to  trv . But if this were just a single step in a longer calculation, a resulting  trv  decoration shows only that something like this happened  at some step . For example:  julia  X5 = @decorated(-3, 3)\n[-3, 3]_com\n\njulia  asin(sqrt(X5))\n[0, 1.5708]_trv\n\njulia  X6 = @decorated(0, 3)\n[0, 3]_com\n\njulia  asin(sqrt(X6))\n[0, 1.5708]_trv  In both cases,  asin(sqrt(X))  gives a result with a  trv  decoration, but\nwe do not know at which step this happened, unless we break down the function into its constituent parts:  julia  sqrt(X5)\n[0, 1.73206]_trv\n\njulia  sqrt(X6)\n[0, 1.73206]_com  This shows that loose evaluation occurred in different parts of the expression in the two different cases.  In general, the  trv  decoration is thus used only to signal that \"something unexpected\" happened during the calculation. Often this is later used to split up the original interval into pieces and reevaluate the function on each piece to refine the information that is obtained about the function.", 
            "title": "Action of functions"
        }
    ]
}