{
    "docs": [
        {
            "location": "/", 
            "text": "ValidatedNumerics.jl\n\n\nValidatedNumerics.jl\n is a Julia package for performing \nValidated Numerics\n in Julia, i.e. \nrigorous\n computations with finite-precision floating-point arithmetic.\n\n\nInstallation\n\n\nTo install the package, from within Julia do\n\n\njulia\n Pkg.add(\"ValidatedNumerics\")\n\n\n\nInterval arithmetic\n\n\nAll calculations are carried out using \ninterval arithmetic\n: all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is \nguaranteed\n to contain the correct result, starting from the given initial data.\n\n\nThe aim of the package is correctness over speed, although performance considerations are also taken into account\n\n\nContents:\n\n\n\n\nBasic usage\n\n\nMulti-dimensional\n\n\nRoot finding\n\n\nRounding\n\n\nDecorations\n\n\n\n\nBibliography\n\n\n\n\nValidated Numerics: A Short Introduction to Rigorous Computations\n, W. Tucker, Princeton University Press (2010)\n\n\nIntroduction to Interval Analysis\n, R.E. Moore, R.B. Kearfott \n M.J. Cloud, SIAM (2009)\n\n\n\n\nRelated packages\n\n\n\n\nMPFI.jl\n, a Julia wrapper around the \nMPFI C library\n, a multiple-precision interval arithmetic library based on MPFR\n\n\nIntervals.jl\n, an alternative implementation of basic interval functions.\n\n\nUnums.jl\n, an implementation of interval\narithmetic with variable precision (\"ubounds\")\n\n\n\n\nAuthors\n\n\n\n\nLuis Benet\n, Instituto de Ciencias F\u00edsicas,\nUniversidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\nDavid P. Sanders\n,\nDepartamento de F\u00edsica, Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\n\n\nContributors\n\n\n\n\nOliver Heimlich\n\n\nNikolay Kryukov\n\n\nJohn Verzani\n\n\n\n\nAcknowledgements\n\n\nThis project was developed in a masters' course in the postgraduate programs in Physics and in Mathematics at UNAM during the second semester of 2013 and the first semester of 2015. We thank the participants of the courses for putting up with the half-baked material and contributing energy and ideas.\n\n\nFinancial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214. LB acknowledges support through a \nC\u00e1tedra Moshinsky\n (2013).\nDPS acknowledges a sabbatical fellowship from CONACYT and Alan Edelman and the Julia group\nat MIT for hosting his sabbatical visit.", 
            "title": "Package"
        }, 
        {
            "location": "/#validatednumericsjl", 
            "text": "ValidatedNumerics.jl  is a Julia package for performing  Validated Numerics  in Julia, i.e.  rigorous  computations with finite-precision floating-point arithmetic.", 
            "title": "ValidatedNumerics.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "To install the package, from within Julia do  julia  Pkg.add(\"ValidatedNumerics\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#interval-arithmetic", 
            "text": "All calculations are carried out using  interval arithmetic : all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is  guaranteed  to contain the correct result, starting from the given initial data.  The aim of the package is correctness over speed, although performance considerations are also taken into account", 
            "title": "Interval arithmetic"
        }, 
        {
            "location": "/#contents", 
            "text": "Basic usage  Multi-dimensional  Root finding  Rounding  Decorations", 
            "title": "Contents:"
        }, 
        {
            "location": "/#bibliography", 
            "text": "Validated Numerics: A Short Introduction to Rigorous Computations , W. Tucker, Princeton University Press (2010)  Introduction to Interval Analysis , R.E. Moore, R.B. Kearfott   M.J. Cloud, SIAM (2009)", 
            "title": "Bibliography"
        }, 
        {
            "location": "/#related-packages", 
            "text": "MPFI.jl , a Julia wrapper around the  MPFI C library , a multiple-precision interval arithmetic library based on MPFR  Intervals.jl , an alternative implementation of basic interval functions.  Unums.jl , an implementation of interval\narithmetic with variable precision (\"ubounds\")", 
            "title": "Related packages"
        }, 
        {
            "location": "/#authors", 
            "text": "Luis Benet , Instituto de Ciencias F\u00edsicas,\nUniversidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)  David P. Sanders ,\nDepartamento de F\u00edsica, Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)", 
            "title": "Authors"
        }, 
        {
            "location": "/#contributors", 
            "text": "Oliver Heimlich  Nikolay Kryukov  John Verzani", 
            "title": "Contributors"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "This project was developed in a masters' course in the postgraduate programs in Physics and in Mathematics at UNAM during the second semester of 2013 and the first semester of 2015. We thank the participants of the courses for putting up with the half-baked material and contributing energy and ideas.  Financial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214. LB acknowledges support through a  C\u00e1tedra Moshinsky  (2013).\nDPS acknowledges a sabbatical fellowship from CONACYT and Alan Edelman and the Julia group\nat MIT for hosting his sabbatical visit.", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/usage/", 
            "text": "MathJax.Hub.Config({\n    TeX: { equationNumbers: { autoNumber: \"AMS\" } }\n  });\n  MathJax.Hub.Config({\n    TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\", \"autobold.js\", \"autoload-all.js\"] }\n  });\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n      processEscapes: true\n    }\n  });\n\n\n\n\n\n\n\n\n\nBasic usage\n\n\nThe basic elements of the package are \nintervals\n, i.e. sets of real numbers (possibly including $\\pm \\infty$) of the form\n\n\n$$[a, b] := { a \\le x \\le b } \\subseteq \\mathbb{R}.$$\n\n\nCreating intervals\n\n\nIntervals are created using the \n@interval\n macro, which takes one or two expressions:\n\n\njulia\n using ValidatedNumerics\n\njulia\n a = @interval(1)\n[1.0, 1.0]\n\njulia\n typeof(ans)\nInterval{Float64} (constructor with 1 method)\n\njulia\n\n\njulia\n b = @interval(1, 2)\n[1.0, 2.0]\n\n\n\n\nThese return objects of the parametrised type \nInterval\n, the basic object in the package.\n\n\nThe constructor of the \nInterval\n type may be used directly, but this is generally not recommended, for the following reason:\n\n\njulia\n a = Interval(0.1, 0.3)\n[0.1, 0.3]\n\njulia\n b = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]\n\n\n\n\nWhat is going on here?\n\n\nDue to the way floating-point arithmetic works, the interval\n\na\n created directly by the constructor \ncontains neither the true real number 0.1, nor 0.3\n.\nThe \n@interval\n macro, however, uses \ndirected rounding\n to \nguarantee\n\nthat the true 0.1 and 0.3 are included in the result.\n\n\nBehind the scenes, the \n@interval\n macro rewrites the expression(s) passed to it, replacing the literals (0.1, 1, etc.) by calls to create correctly-rounded intervals, handled by the \nconvert\n\nfunction.\n\n\nThis allows us to write, for example\n\n\njulia\n @interval sin(0.1) + cos(0.2)\n\n\n\n\nand get a result that is equivalent to\n\n\njulia\n sin(@interval(0.1)) + cos(@interval(0.2))\n\n\n\n\nThis can also be used with user-defined functions:\n\n\njulia\n f(x) = 2x\nf (generic function with 1 method)\n\njulia\n f(@interval(0.1))\n[0.19999999999999998, 0.2]\n\njulia\n @interval f(0.1)\n[0.19999999999999998, 0.2]\n\n\n\n\n$\\pi$\n\n\nYou can create correctly-rounded intervals containing $\\pi$:\n\n\njulia\n @interval(pi)\n[3.141592653589793, 3.1415926535897936]\n\n\n\n\nand embed it in expressions:\n\n\njulia\n @interval(3*pi/2 + 1)\n[5.71238898038469, 5.712388980384691]\n\njulia\n @interval 3\u03c0/2 + 1\n[5.71238898038469, 5.712388980384691]\n\n\n\n\nExamples\n\n\nIntervals may be constructed using rationals:\n\n\njulia\n @interval(1//10)\n[0.09999999999999999, 0.1]\n\n\n\n\nReal literals are handled by internally converting them\nto rationals using \nrationalize\n. This is produces\na result that contains the computer's \"best guess\" for\nthe real number the user \"had in mind\":\n\n\njulia\n @interval(0.1)\n[0.09999999999999999, 0.1]\n\n\n\n\nIf you know exactly which floating-point number you need and really\nwant to make a thin interval (i.e., an interval of the form $[a,a]$), you can just\nuse the \nInterval\n constructor:\n\n\njulia\n Interval(0.1)\n[0.1, 0.1]\n\n\n\n\nStrings may be used:\n\n\njulia\n @interval(\n0.1\n*\n2\n)\n[0.19999999999999998, 0.2]\n\n\n\n\nStrings in the form of intervals may also be used:\n\n\njulia\n @interval \n[1.2, 3.4]\n\n[1.2, 3.4000000000000004]\n\n\n\n\nIntervals can be created from variables:\n\n\njulia\n a = 3.6\n3.6\n\njulia\n b = @interval(a)\n[3.5999999999999996, 3.6]\n\n\n\n\nThe upper and lower bounds of the interval may be accessed using the fields\n\nlo\n and \nhi\n:\n\n\njulia\n b.lo\n3.5999999999999996\n\njulia\n b.hi\n3.6\n\n\n\n\nThe diameter (length) of an interval is obtained using \ndiam(b)\n;\nfor numbers that cannot be represented in base 2\n(i.e., whose \nbinary\n expansion is infinite or exceeds the current precision),\n the diameter of newly-created thin intervals corresponds to the local machine epsilon (\neps\n) in the \n:narrow\n interval-rounding mode:\n\n\njulia\n diam(b)\n4.440892098500626e-16\n\njulia\n eps(b.lo)\n4.440892098500626e-16\n\n\n\n\nStarting with v0.3, you can use additional syntax for creating intervals more easily:\nthe \n..\n operator,\n\n\njulia\n 0.1..0.3\n[0.09999999999999999, 0.30000000000000004]\n\n\n\n\nand the \n@I_str\n string macro:\n\n\njulia\n I\n3.1\n\n[3.0999999999999996, 3.1]\n\njulia\n I\n[3.1, 3.2]\n\n[3.0999999999999996, 3.2]\n\n\n\n\nArithmetic\n\n\nBasic arithmetic operations (\n+\n, \n-\n, \n*\n, \n/\n, \n^\n) are defined for pairs of intervals in a standard way (see, e.g., the book by Tucker): the result is the smallest interval containing the result of operating with each element of each interval. That is, for two intervals $X$ and $Y$ and an operation $\\circ$, we define the operation on the two intervals by\n$$X \\circ Y := { x \\circ y: x \\in X \\text{ and } y \\in Y }.$$  Again, directed rounding is used if necessary.\n\n\nFor example:\n\n\njulia\n a = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]\n\njulia\n b = @interval(0.3, 0.6)\n[0.3, 0.6000000000000001]\n\njulia\n a + b\n[0.39999999999999997, 0.9000000000000001]\n\n\n\n\nHowever, subtraction of two intervals gives an initially unexpected result, due to the above definition:\n\n\njulia\n a = @interval(0, 1)\n[0.0, 1.0]\n\njulia\n a - a\n[-1.0, 1.0]\n\n\n\n\nChanging the precision\n\n\nBy default, the \n@interval\n macro creates intervals of \nFloat64\ns.\nThis may be changed using the \nsetprecision\n function:\n\n\njulia\n setprecision(Interval, 256)\n256\n\njulia\n @interval 3\u03c0/2 + 1\n[5.712388980384689857693965074919254326295754099062658731462416888461724609429262e+00, 5.712388980384689857693965074919254326295754099062658731462416888461724609429401e+00]\u2082\u2085\u2086\n\n\n\n\nThe subscript \n256\n at the end denotes the precision.\n\n\nTo change back to \nFloat64\ns, use\n\n\njulia\n setprecision(Interval, Float64)\nFloat64\n\njulia\n @interval(pi)\n[3.141592653589793, 3.1415926535897936]\n\n\n\n\nTo check which mode is currently set, use\n\n\njulia\n precision(Interval)\n(Float64,256)\n\n\n\n\nThe result is a tuple of the type (currently \nFloat64\n or \nBigFloat\n) and the current \nBigFloat\n precision.\n\n\nNote that the \nBigFloat\n precision is set internally by \nsetprecision(Interval)\n.\nYou should not use \nsetprecision(BigFloat)\n directly,\n\nsince the package carries out additional steps to ensure internal\nconsistency of operations involving \u03c0, in particular\ntrigonometric functions.\n\n\nElementary functions\n\n\nThe main elementary functions are implemented, acting on both\n\nInterval{Float64}\n and \nInterval{BigFloat}\n.\n\n\nThe functions that act on \nInterval{Float64}\n internally use routines the \nCRlibm\n library\n where possible, i.e. for the following\nfunctions defined in that library:\n\n\n\n\nexp\n, \nexpm1\n\n\nlog\n, \nlog1p\n, \nlog2\n, \nlog10\n\n\nsin\n, \ncos\n, \ntan\n\n\nasin\n, \nacos\n, \natan\n\n\nsinh\n, \ncosh\n\n\n\n\nOther functions that are implemented for \nInterval{Float64}\n internally convert\nto a \nInterval{BigFloat}\n, which then use routines from the \nMPFR\n library\n(\nBigFloat\n in Julia):\n\n\n\n\n^\n\n\nexp2\n, \nexp10\n\n\natan2\n, \natanh\n\n\n\n\nNote, in particular, that in order to obtain correct rounding for the power function (\n^\n),\nintervals are converted to and from \nBigFloat\n; this implies a significant slow-down in this case.\n\n\nExamples:\n\n\njulia\n a = @interval(1)\n[1.0, 1.0]\n\njulia\n sin(a)\n[0.8414709848078965, 0.8414709848078966]\n\njulia\n cos(cosh(a))\n[0.027712143770207736, 0.02771214377020796]\n\n\n\n\njulia\n setprecision(Interval, 53)\n53\n\njulia\n sin(@interval(1))\n[8.414709848078965e-01, 8.4147098480789662e-01]\u2085\u2083\n\njulia\n @interval sin(0.1) + cos(0.2)\n[1.0798999944880696e+00, 1.0798999944880701e+00]\u2085\u2083\n\n\n\n\njulia\n setprecision(Interval, 128)\n128\n\njulia\n @interval sin(1)\n[8.41470984807896506652502321630298999621e-01, 8.414709848078965066525023216302989996239e-01]\u2081\u2082\u2088\n\n\n\n\nInterval rounding modes\n\n\nBy default, the directed rounding used corresponds to using the \nRoundDown\n and \nRoundUp\n rounding modes when performing calculations; this gives the narrowest resulting intervals, and is set by\n\n\nsetrounding(Interval, :narrow)\n\n\n\n\nAn alternative rounding method is to perform calculations using the (standard) \nRoundNearest\n rounding mode, and then widen the result by one machine epsilon in each direction using \nprevfloat\n and \nnextfloat\n. This is achived by\n\n\nsetrounding(Interval, :wide)\n\n\n\n\nIt generally results in wider intervals, but seems to be significantly faster.\n\n\nThe current interval rounding mode may be obtained by\n\n\nrounding(Interval)", 
            "title": "Basic usage"
        }, 
        {
            "location": "/usage/#basic-usage", 
            "text": "The basic elements of the package are  intervals , i.e. sets of real numbers (possibly including $\\pm \\infty$) of the form  $$[a, b] := { a \\le x \\le b } \\subseteq \\mathbb{R}.$$", 
            "title": "Basic usage"
        }, 
        {
            "location": "/usage/#creating-intervals", 
            "text": "Intervals are created using the  @interval  macro, which takes one or two expressions:  julia  using ValidatedNumerics\n\njulia  a = @interval(1)\n[1.0, 1.0]\n\njulia  typeof(ans)\nInterval{Float64} (constructor with 1 method)\n\njulia \n\njulia  b = @interval(1, 2)\n[1.0, 2.0]  These return objects of the parametrised type  Interval , the basic object in the package.  The constructor of the  Interval  type may be used directly, but this is generally not recommended, for the following reason:  julia  a = Interval(0.1, 0.3)\n[0.1, 0.3]\n\njulia  b = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]  What is going on here?  Due to the way floating-point arithmetic works, the interval a  created directly by the constructor  contains neither the true real number 0.1, nor 0.3 .\nThe  @interval  macro, however, uses  directed rounding  to  guarantee \nthat the true 0.1 and 0.3 are included in the result.  Behind the scenes, the  @interval  macro rewrites the expression(s) passed to it, replacing the literals (0.1, 1, etc.) by calls to create correctly-rounded intervals, handled by the  convert \nfunction.  This allows us to write, for example  julia  @interval sin(0.1) + cos(0.2)  and get a result that is equivalent to  julia  sin(@interval(0.1)) + cos(@interval(0.2))  This can also be used with user-defined functions:  julia  f(x) = 2x\nf (generic function with 1 method)\n\njulia  f(@interval(0.1))\n[0.19999999999999998, 0.2]\n\njulia  @interval f(0.1)\n[0.19999999999999998, 0.2]", 
            "title": "Creating intervals"
        }, 
        {
            "location": "/usage/#pi", 
            "text": "You can create correctly-rounded intervals containing $\\pi$:  julia  @interval(pi)\n[3.141592653589793, 3.1415926535897936]  and embed it in expressions:  julia  @interval(3*pi/2 + 1)\n[5.71238898038469, 5.712388980384691]\n\njulia  @interval 3\u03c0/2 + 1\n[5.71238898038469, 5.712388980384691]", 
            "title": "$\\pi$"
        }, 
        {
            "location": "/usage/#examples", 
            "text": "Intervals may be constructed using rationals:  julia  @interval(1//10)\n[0.09999999999999999, 0.1]  Real literals are handled by internally converting them\nto rationals using  rationalize . This is produces\na result that contains the computer's \"best guess\" for\nthe real number the user \"had in mind\":  julia  @interval(0.1)\n[0.09999999999999999, 0.1]  If you know exactly which floating-point number you need and really\nwant to make a thin interval (i.e., an interval of the form $[a,a]$), you can just\nuse the  Interval  constructor:  julia  Interval(0.1)\n[0.1, 0.1]  Strings may be used:  julia  @interval( 0.1 * 2 )\n[0.19999999999999998, 0.2]  Strings in the form of intervals may also be used:  julia  @interval  [1.2, 3.4] \n[1.2, 3.4000000000000004]  Intervals can be created from variables:  julia  a = 3.6\n3.6\n\njulia  b = @interval(a)\n[3.5999999999999996, 3.6]  The upper and lower bounds of the interval may be accessed using the fields lo  and  hi :  julia  b.lo\n3.5999999999999996\n\njulia  b.hi\n3.6  The diameter (length) of an interval is obtained using  diam(b) ;\nfor numbers that cannot be represented in base 2\n(i.e., whose  binary  expansion is infinite or exceeds the current precision),\n the diameter of newly-created thin intervals corresponds to the local machine epsilon ( eps ) in the  :narrow  interval-rounding mode:  julia  diam(b)\n4.440892098500626e-16\n\njulia  eps(b.lo)\n4.440892098500626e-16  Starting with v0.3, you can use additional syntax for creating intervals more easily:\nthe  ..  operator,  julia  0.1..0.3\n[0.09999999999999999, 0.30000000000000004]  and the  @I_str  string macro:  julia  I 3.1 \n[3.0999999999999996, 3.1]\n\njulia  I [3.1, 3.2] \n[3.0999999999999996, 3.2]", 
            "title": "Examples"
        }, 
        {
            "location": "/usage/#arithmetic", 
            "text": "Basic arithmetic operations ( + ,  - ,  * ,  / ,  ^ ) are defined for pairs of intervals in a standard way (see, e.g., the book by Tucker): the result is the smallest interval containing the result of operating with each element of each interval. That is, for two intervals $X$ and $Y$ and an operation $\\circ$, we define the operation on the two intervals by\n$$X \\circ Y := { x \\circ y: x \\in X \\text{ and } y \\in Y }.$$  Again, directed rounding is used if necessary.  For example:  julia  a = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]\n\njulia  b = @interval(0.3, 0.6)\n[0.3, 0.6000000000000001]\n\njulia  a + b\n[0.39999999999999997, 0.9000000000000001]  However, subtraction of two intervals gives an initially unexpected result, due to the above definition:  julia  a = @interval(0, 1)\n[0.0, 1.0]\n\njulia  a - a\n[-1.0, 1.0]", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/usage/#changing-the-precision", 
            "text": "By default, the  @interval  macro creates intervals of  Float64 s.\nThis may be changed using the  setprecision  function:  julia  setprecision(Interval, 256)\n256\n\njulia  @interval 3\u03c0/2 + 1\n[5.712388980384689857693965074919254326295754099062658731462416888461724609429262e+00, 5.712388980384689857693965074919254326295754099062658731462416888461724609429401e+00]\u2082\u2085\u2086  The subscript  256  at the end denotes the precision.  To change back to  Float64 s, use  julia  setprecision(Interval, Float64)\nFloat64\n\njulia  @interval(pi)\n[3.141592653589793, 3.1415926535897936]  To check which mode is currently set, use  julia  precision(Interval)\n(Float64,256)  The result is a tuple of the type (currently  Float64  or  BigFloat ) and the current  BigFloat  precision.  Note that the  BigFloat  precision is set internally by  setprecision(Interval) .\nYou should not use  setprecision(BigFloat)  directly, \nsince the package carries out additional steps to ensure internal\nconsistency of operations involving \u03c0, in particular\ntrigonometric functions.", 
            "title": "Changing the precision"
        }, 
        {
            "location": "/usage/#elementary-functions", 
            "text": "The main elementary functions are implemented, acting on both Interval{Float64}  and  Interval{BigFloat} .  The functions that act on  Interval{Float64}  internally use routines the  CRlibm  library  where possible, i.e. for the following\nfunctions defined in that library:   exp ,  expm1  log ,  log1p ,  log2 ,  log10  sin ,  cos ,  tan  asin ,  acos ,  atan  sinh ,  cosh   Other functions that are implemented for  Interval{Float64}  internally convert\nto a  Interval{BigFloat} , which then use routines from the  MPFR  library\n( BigFloat  in Julia):   ^  exp2 ,  exp10  atan2 ,  atanh   Note, in particular, that in order to obtain correct rounding for the power function ( ^ ),\nintervals are converted to and from  BigFloat ; this implies a significant slow-down in this case.  Examples:  julia  a = @interval(1)\n[1.0, 1.0]\n\njulia  sin(a)\n[0.8414709848078965, 0.8414709848078966]\n\njulia  cos(cosh(a))\n[0.027712143770207736, 0.02771214377020796]  julia  setprecision(Interval, 53)\n53\n\njulia  sin(@interval(1))\n[8.414709848078965e-01, 8.4147098480789662e-01]\u2085\u2083\n\njulia  @interval sin(0.1) + cos(0.2)\n[1.0798999944880696e+00, 1.0798999944880701e+00]\u2085\u2083  julia  setprecision(Interval, 128)\n128\n\njulia  @interval sin(1)\n[8.41470984807896506652502321630298999621e-01, 8.414709848078965066525023216302989996239e-01]\u2081\u2082\u2088", 
            "title": "Elementary functions"
        }, 
        {
            "location": "/usage/#interval-rounding-modes", 
            "text": "By default, the directed rounding used corresponds to using the  RoundDown  and  RoundUp  rounding modes when performing calculations; this gives the narrowest resulting intervals, and is set by  setrounding(Interval, :narrow)  An alternative rounding method is to perform calculations using the (standard)  RoundNearest  rounding mode, and then widen the result by one machine epsilon in each direction using  prevfloat  and  nextfloat . This is achived by  setrounding(Interval, :wide)  It generally results in wider intervals, but seems to be significantly faster.  The current interval rounding mode may be obtained by  rounding(Interval)", 
            "title": "Interval rounding modes"
        }, 
        {
            "location": "/multidim/", 
            "text": "Multi-dimensional boxes\n\n\nStarting with v0.3, multi-dimensional (hyper-)boxes are implemented in the\n\nIntervalBox\n type.\nThese represent Cartesian products of intervals, i.e. rectangles (in 2D),\ncuboids (in 3D), etc.\n\n\nIntervalBox\nes are constructed from an array of \nInterval\ns; it is\noften convenient to use the \n..\n notation:\n\n\njulia\n X = IntervalBox(1..3, 2..4)\n[1.0, 3.0] \u00d7 [2.0, 4.0]\n\njulia\n Y = IntervalBox(2..4, 3..5)\n[2.0, 4.0] \u00d7 [3.0, 5.0]\n\n\n\n\nSeveral operations are defined on \nIntervalBox\nes, for example:\n\n\njulia\n X \u2229 Y\n[2.0, 3.0] \u00d7 [3.0, 4.0]\n\njulia\n X \u2286 Y\nfalse\n\n\n\n\nTo facilitate working with \nIntervalBox\nes, a macro \n@intervalbox\n is defined.\nGiven a multi-dimensional function taking several inputs, this creates both the original form and a\nversion that works with a single \nIntervalBox\n argument, e.g.\n\n\njulia\n @intervalbox f(x, y) = (x + y, x - y)\nf (generic function with 2 methods)\n\njulia\n f(1..1, 2..2)  \n([3.0, 3.0],[-1.0, -1.0])\n\njulia\n X = IntervalBox(1..1, 2..2)\n[1.0, 1.0] \u00d7 [2.0, 2.0]\n\njulia\n f(X)\n[3.0, 3.0] \u00d7 [-1.0, -1.0]\n\n\n\n\nThe first version takes a tuple of \nInterval\ns and returns another tuple of \nInterval\ns;\nthe second version takes a single \nIntervalBox\n and automatically does the\nnecessary unpacking and packing to return an \nIntervalBox.", 
            "title": "Multi-dimensional"
        }, 
        {
            "location": "/multidim/#multi-dimensional-boxes", 
            "text": "Starting with v0.3, multi-dimensional (hyper-)boxes are implemented in the IntervalBox  type.\nThese represent Cartesian products of intervals, i.e. rectangles (in 2D),\ncuboids (in 3D), etc.  IntervalBox es are constructed from an array of  Interval s; it is\noften convenient to use the  ..  notation:  julia  X = IntervalBox(1..3, 2..4)\n[1.0, 3.0] \u00d7 [2.0, 4.0]\n\njulia  Y = IntervalBox(2..4, 3..5)\n[2.0, 4.0] \u00d7 [3.0, 5.0]  Several operations are defined on  IntervalBox es, for example:  julia  X \u2229 Y\n[2.0, 3.0] \u00d7 [3.0, 4.0]\n\njulia  X \u2286 Y\nfalse  To facilitate working with  IntervalBox es, a macro  @intervalbox  is defined.\nGiven a multi-dimensional function taking several inputs, this creates both the original form and a\nversion that works with a single  IntervalBox  argument, e.g.  julia  @intervalbox f(x, y) = (x + y, x - y)\nf (generic function with 2 methods)\n\njulia  f(1..1, 2..2)  \n([3.0, 3.0],[-1.0, -1.0])\n\njulia  X = IntervalBox(1..1, 2..2)\n[1.0, 1.0] \u00d7 [2.0, 2.0]\n\njulia  f(X)\n[3.0, 3.0] \u00d7 [-1.0, -1.0]  The first version takes a tuple of  Interval s and returns another tuple of  Interval s;\nthe second version takes a single  IntervalBox  and automatically does the\nnecessary unpacking and packing to return an  IntervalBox.", 
            "title": "Multi-dimensional boxes"
        }, 
        {
            "location": "/root_finding/", 
            "text": "MathJax.Hub.Config({\n    TeX: { equationNumbers: { autoNumber: \"AMS\" } }\n  });\n  MathJax.Hub.Config({\n    TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\", \"autobold.js\", \"autoload-all.js\"] }\n  });\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n      processEscapes: true\n    }\n  });\n\n\n\n\n\n\n\n\n\nRoot finding\n\n\nInterval arithmetic not only provides guaranteed numerical calculations; it also\nmakes possible fundamentally new algorithms.\n\n\nInterval Newton method\n\n\nOne such algorithm is the \ninterval Newton method\n. This is a version of the\nstandard Newton (or Newton-Raphson) algorithm, an iterative method for finding\nroots (zeros) of functions.\nThe interval version, however, is fundamentally different from its standard\ncounterpart, in that it can (under the best circumstances) provide rigorous\n\nguarantees\n about the presence or absence and uniqueness of roots of a given\nfunction in a given interval, and tells us explicitly when it is unable to\nprovide such a guarantee.\n\n\nThe idea of the Newton method is to calculate a root $x^\\ast$ of a function\n$f$ [i.e., a value such that $f(x^*) = 0$] from an initial guess $x$ using\n\n\n$$x^* = x - \\frac{f(x)}{f'(\\xi)},$$\n\n\nfor some $\\xi$ between $x$ and $x^*$. Since $\\xi$ is unknown, we can bound it as\n\n\n$$f'(\\xi) \\in F'(X),$$\n\n\nwhere $X$ is a containing interval and $F'(X)$ denotes the \ninterval extension\n\nof the function $f$, consisting of applying the same operations as the function\n$f$ to the interval $X$.\n\n\nWe define an \ninterval Newton operator\n $\\mathcal{N}$ as follows:\n\n\n$$\\mathcal{N}(X) := m(X) - \\frac{F(m(X))}{F'(X)},$$\n\n\nwhere $m(X)$  is the midpoint of $X$ converted into an interval.\n\n\nIt turns out that $\\mathcal{N}$ tells us precisely whether there is a root of $f$ in\nthe interval $X$: there is no root if $\\mathcal{N}(X) \\cap X = \\emptyset$, and there is\na unique root if $\\mathcal{N}(X) \\subseteq X$.\nThere is also an extension to intervals in which the derivative $F'(X)$ contains $0$,\nin which case the Newton operator returns a union of two intervals.\n\n\nIterating the Newton operator on the resulting sets gives a rigorous algorithm\nthat is \nguaranteed to find all roots\n of a\nreal function in a given interval (or to inform us if it is unable to do so,\nfor example at a multiple root); see Tucker's book for more details.\n\n\nUsage of the interval Newton method\n\n\nThe interval Newton method is implemented for real functions of a single\nvariable as the function \nnewton\n. For example, we can calculate rigorously the square roots of 2:\n\n\njulia\n using ValidatedNumerics\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\n\n\n\nThe function \nnewton\n  is passed the function and the interval in which to search for roots;\nit returns an array of \nRoot\n objects, that contain the interval where a root is found,\ntogether with a symbol \n:unique\n if there is guaranteed to be a unique root in that\ninterval, or \n:unknown\n if the Newton method is unable to make a guarantee, for example,\nwhen there is a double root:\n\n\njulia\n newton(f, @interval(-5,5))\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([2.0, 2.0], :unique)\n\n\n\n\nThe Newton method may be applied directly to a vector of known roots,\nfor example to refine them with higher precision:\n\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n roots = newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\njulia\n setprecision(Interval, 256)\n256\n\njulia\n newton(f, roots)\n2-element Array{ValidatedNumerics.Root{Base.MPFR.BigFloat},1}:\n Root([-1.414213562373095048801688724209698078569671875376948073176679737990732478462119, -1.414213562373095048801688724209698078569671875376948073176679737990732478462102]\u2082\u2085\u2086, :unique)\n Root([1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1.414213562373095048801688724209698078569671875376948073176679737990732478462119]\u2082\u2085\u2086, :unique)\n\njulia\n abs(roots2[2].interval.lo - sqrt(big(2)))\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n\n\n\n\nKrawczyk method\n\n\nAn alternative method is the \nKrawczyk method\n, implemented in the function\n\nkrawczyk\n, with the same interface as the Newton method:\n\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n krawczyk(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730954, -1.4142135623730947], :unique)\n Root([1.4142135623730947, 1.4142135623730954], :unique)\n\njulia\n newton(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\n\n\n\nThe Krawczyk method really comes into its own for higher-dimensional functions;\nthis is planned to be implemented in the future.\n\n\nfind_roots\n interface\n\n\nAutomatic differentiation is used to calculate the derivative used in the Newton method\nif the derivative function is not given explicitly as the second argument to \nnewton\n.\n\n\nAn interface \nfind_roots\n is provided, which does not require an interval to be passed:\n\n\njulia\n find_roots(f, -5, 5)\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([1.9999999999999998, 2.0000000000000004], :unique)\n\n\n\n\nThere is also a version \nfind_roots_midpoint\n that returns three vectors:\nthe midpoint of each interval; the radius of the interval; and the symbol.\nThis may be useful for someone who just wishes to find roots of a function,\nwithout wanting to understand how to manipulate interval objects:\n\n\njulia\n find_roots_midpoint(f, -5, 5)\n([-1.4142135623730951,1.414213562373095],[2.220446049250313e-16,4.440892098500626e-16],[:unique,:unique])\n\n\n\n\nThis uses the function \nmidpoint_radius\n, that returns the midpoint and radius\nof a given interval:\n\n\njulia\n a = @interval(0.1, 0.2)\n[0.09999999999999999, 0.2]\n\njulia\n midpoint_radius(a)\n(0.15,0.05000000000000002)", 
            "title": "Root finding"
        }, 
        {
            "location": "/root_finding/#root-finding", 
            "text": "Interval arithmetic not only provides guaranteed numerical calculations; it also\nmakes possible fundamentally new algorithms.", 
            "title": "Root finding"
        }, 
        {
            "location": "/root_finding/#interval-newton-method", 
            "text": "One such algorithm is the  interval Newton method . This is a version of the\nstandard Newton (or Newton-Raphson) algorithm, an iterative method for finding\nroots (zeros) of functions.\nThe interval version, however, is fundamentally different from its standard\ncounterpart, in that it can (under the best circumstances) provide rigorous guarantees  about the presence or absence and uniqueness of roots of a given\nfunction in a given interval, and tells us explicitly when it is unable to\nprovide such a guarantee.  The idea of the Newton method is to calculate a root $x^\\ast$ of a function\n$f$ [i.e., a value such that $f(x^*) = 0$] from an initial guess $x$ using  $$x^* = x - \\frac{f(x)}{f'(\\xi)},$$  for some $\\xi$ between $x$ and $x^*$. Since $\\xi$ is unknown, we can bound it as  $$f'(\\xi) \\in F'(X),$$  where $X$ is a containing interval and $F'(X)$ denotes the  interval extension \nof the function $f$, consisting of applying the same operations as the function\n$f$ to the interval $X$.  We define an  interval Newton operator  $\\mathcal{N}$ as follows:  $$\\mathcal{N}(X) := m(X) - \\frac{F(m(X))}{F'(X)},$$  where $m(X)$  is the midpoint of $X$ converted into an interval.  It turns out that $\\mathcal{N}$ tells us precisely whether there is a root of $f$ in\nthe interval $X$: there is no root if $\\mathcal{N}(X) \\cap X = \\emptyset$, and there is\na unique root if $\\mathcal{N}(X) \\subseteq X$.\nThere is also an extension to intervals in which the derivative $F'(X)$ contains $0$,\nin which case the Newton operator returns a union of two intervals.  Iterating the Newton operator on the resulting sets gives a rigorous algorithm\nthat is  guaranteed to find all roots  of a\nreal function in a given interval (or to inform us if it is unable to do so,\nfor example at a multiple root); see Tucker's book for more details.", 
            "title": "Interval Newton method"
        }, 
        {
            "location": "/root_finding/#usage-of-the-interval-newton-method", 
            "text": "The interval Newton method is implemented for real functions of a single\nvariable as the function  newton . For example, we can calculate rigorously the square roots of 2:  julia  using ValidatedNumerics\n\njulia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)  The function  newton   is passed the function and the interval in which to search for roots;\nit returns an array of  Root  objects, that contain the interval where a root is found,\ntogether with a symbol  :unique  if there is guaranteed to be a unique root in that\ninterval, or  :unknown  if the Newton method is unable to make a guarantee, for example,\nwhen there is a double root:  julia  newton(f, @interval(-5,5))\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([2.0, 2.0], :unique)  The Newton method may be applied directly to a vector of known roots,\nfor example to refine them with higher precision:  julia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  roots = newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\njulia  setprecision(Interval, 256)\n256\n\njulia  newton(f, roots)\n2-element Array{ValidatedNumerics.Root{Base.MPFR.BigFloat},1}:\n Root([-1.414213562373095048801688724209698078569671875376948073176679737990732478462119, -1.414213562373095048801688724209698078569671875376948073176679737990732478462102]\u2082\u2085\u2086, :unique)\n Root([1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1.414213562373095048801688724209698078569671875376948073176679737990732478462119]\u2082\u2085\u2086, :unique)\n\njulia  abs(roots2[2].interval.lo - sqrt(big(2)))\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000", 
            "title": "Usage of the interval Newton method"
        }, 
        {
            "location": "/root_finding/#krawczyk-method", 
            "text": "An alternative method is the  Krawczyk method , implemented in the function krawczyk , with the same interface as the Newton method:  julia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  krawczyk(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730954, -1.4142135623730947], :unique)\n Root([1.4142135623730947, 1.4142135623730954], :unique)\n\njulia  newton(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)  The Krawczyk method really comes into its own for higher-dimensional functions;\nthis is planned to be implemented in the future.", 
            "title": "Krawczyk method"
        }, 
        {
            "location": "/root_finding/#find_roots-interface", 
            "text": "Automatic differentiation is used to calculate the derivative used in the Newton method\nif the derivative function is not given explicitly as the second argument to  newton .  An interface  find_roots  is provided, which does not require an interval to be passed:  julia  find_roots(f, -5, 5)\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([1.9999999999999998, 2.0000000000000004], :unique)  There is also a version  find_roots_midpoint  that returns three vectors:\nthe midpoint of each interval; the radius of the interval; and the symbol.\nThis may be useful for someone who just wishes to find roots of a function,\nwithout wanting to understand how to manipulate interval objects:  julia  find_roots_midpoint(f, -5, 5)\n([-1.4142135623730951,1.414213562373095],[2.220446049250313e-16,4.440892098500626e-16],[:unique,:unique])  This uses the function  midpoint_radius , that returns the midpoint and radius\nof a given interval:  julia  a = @interval(0.1, 0.2)\n[0.09999999999999999, 0.2]\n\njulia  midpoint_radius(a)\n(0.15,0.05000000000000002)", 
            "title": "find_roots interface"
        }, 
        {
            "location": "/rounding/", 
            "text": "Why is rounding necessary?\n\n\nConsider the Julia code\n\n\nx = 0.1\n\n\n\nThis apparently stores the value 0.1 in a variable \nx\n of type \nFloat64\n.\nIn fact, however, it stores a \nslightly different\n number than 0.1, since 0.1 itself \ncannot be represented in binary floating point arithmetic, at any precision\n.\n\n\nThe value that is actually stored in the variable can be conveniently determined in Julia using arbitrary precision arithmetic (\nBigFloat\ns):\n\n\njulia\n big(0.1)\n\n1.000000000000000055511151231257827021181583404541015625e-01 with 256 bits of precision\n\n\n\nSo, in fact, the value is slightly greater than 0.1. By default, such calculations are done in round-to-nearest mode (\nRoundNearest\n); i.e., the nearest representable floating-point number to 0.1 is used.\n\n\nSuppose now that we created an interval as\n\n\njulia\n II = Interval(0.1)\n[0.1, 0.1]\n\n\n\nIt looks like the interval contains the true value 0.1, but from the above discussion we see that, in fact, \nit does not\n. In order to contain the true value 0.1, the end-points of the interval must be rounded outwards (\"directed rounding\"): the lower bound is rounded down, and the upper bound is rounded up.\n\n\nThis rounding is handled by the \n@interval\n  macro, which generates correctly-rounded intervals:\n\n\njulia\n a = @interval(0.1)\n[0.09999999999999999, 0.1]\n\n\n\n\nThe true 0.1 is now correctly contained in the intervals, so that any calculations on these intervals will contain the true result of calculating with 0.1. For example, if we define\n\n\njulia\n f(x) = 2x + 0.2\n\n\n\n\nthen we can apply the function \nf\n to the interval \na\n to obtain\n\n\njulia\n f(a)\n[0.39999999999999997, 0.4]\n\n\n\n\nThe result correctly contains the true 0.4.\n\n\nMore detail\n\n\nLet's look at the internal representation of the \nFloat64\n number 0.1:\n\n\njulia\n bits(0.1)\n\n0011111110111001100110011001100110011001100110011001100110011010\n\n\n\n\n\nThe last 53 bits of these 64 bits correspond to the binary expansion of 0.1, which is\n\n\n0.000110011001100110011001100110011001100...\n\n\n\n\nWe see that the expansion is periodic; in fact, the binary expansion of 0.1 has an infinite repetition of the sequence of digits \n1100\n. It is thus \nimpossible\n to represent the decimal 0.1 in binary, with \nany\n precision.\n\n\nJulia allows us to get closer to the true value using \nBigFloat\ns:\n\n\njulia\n using Compat\n\njulia\n @compat parse(BigFloat, \n0.1\n)\n1.000000000000000000000000000000000000000000000000000000000000000000000000000002e-01 with 256 bits of precision\n\n\n\n\nBut the 2 and the end of the decimal expansion is the giveaway that this number is still not exactly 0.1\n\n\nThe true value must be approximated by a floating-point number with fixed precision -- this procedure is called \nrounding\n. For positive numbers, rounding down may be accomplished simply by truncating the expansion; rounding up is accomplished by incrementing the final binary digit and propagating any resulting changes.", 
            "title": "Rounding"
        }, 
        {
            "location": "/rounding/#why-is-rounding-necessary", 
            "text": "Consider the Julia code  x = 0.1  This apparently stores the value 0.1 in a variable  x  of type  Float64 .\nIn fact, however, it stores a  slightly different  number than 0.1, since 0.1 itself  cannot be represented in binary floating point arithmetic, at any precision .  The value that is actually stored in the variable can be conveniently determined in Julia using arbitrary precision arithmetic ( BigFloat s):  julia  big(0.1)\n\n1.000000000000000055511151231257827021181583404541015625e-01 with 256 bits of precision  So, in fact, the value is slightly greater than 0.1. By default, such calculations are done in round-to-nearest mode ( RoundNearest ); i.e., the nearest representable floating-point number to 0.1 is used.  Suppose now that we created an interval as  julia  II = Interval(0.1)\n[0.1, 0.1]  It looks like the interval contains the true value 0.1, but from the above discussion we see that, in fact,  it does not . In order to contain the true value 0.1, the end-points of the interval must be rounded outwards (\"directed rounding\"): the lower bound is rounded down, and the upper bound is rounded up.  This rounding is handled by the  @interval   macro, which generates correctly-rounded intervals:  julia  a = @interval(0.1)\n[0.09999999999999999, 0.1]  The true 0.1 is now correctly contained in the intervals, so that any calculations on these intervals will contain the true result of calculating with 0.1. For example, if we define  julia  f(x) = 2x + 0.2  then we can apply the function  f  to the interval  a  to obtain  julia  f(a)\n[0.39999999999999997, 0.4]  The result correctly contains the true 0.4.", 
            "title": "Why is rounding necessary?"
        }, 
        {
            "location": "/rounding/#more-detail", 
            "text": "Let's look at the internal representation of the  Float64  number 0.1:  julia  bits(0.1) 0011111110111001100110011001100110011001100110011001100110011010   The last 53 bits of these 64 bits correspond to the binary expansion of 0.1, which is  0.000110011001100110011001100110011001100...  We see that the expansion is periodic; in fact, the binary expansion of 0.1 has an infinite repetition of the sequence of digits  1100 . It is thus  impossible  to represent the decimal 0.1 in binary, with  any  precision.  Julia allows us to get closer to the true value using  BigFloat s:  julia  using Compat\n\njulia  @compat parse(BigFloat,  0.1 )\n1.000000000000000000000000000000000000000000000000000000000000000000000000000002e-01 with 256 bits of precision  But the 2 and the end of the decimal expansion is the giveaway that this number is still not exactly 0.1  The true value must be approximated by a floating-point number with fixed precision -- this procedure is called  rounding . For positive numbers, rounding down may be accomplished simply by truncating the expansion; rounding up is accomplished by incrementing the final binary digit and propagating any resulting changes.", 
            "title": "More detail"
        }, 
        {
            "location": "/decorations/", 
            "text": "Decorations:\n\n\nDecorations are flags or labels attached to intervals to indicate the status of a given interval as the product of a function evaluation on a given initial interval.\n\n\nThe possible decorations and their ordering are as follows (pg. 46):\n\ncom\n \n \ndac\n \n \ndef\n \n \ntrv\n \n \nill\n.\n\n\n\n\n\n\ncom\n (\"common\"): The meanings are (pg. 44): x is a bounded, nonempty subset of Dom(f); f is\ncontinuous at each point of x; and the computed interval f(x) is bounded.\nx is a nonempty subset of Dom(f), and the restriction of f to x is continuous;\n\n\n\n\n\n\ndac\n (\"defined \n continuous\"): x is a nonempty subset of Dom(f), and the\nrestriction of f to x is continuous;\n\n\n\n\n\n\ndef\n (\"defined\"): x is a nonempty subset of Dom(f), i.e. f is defined at each point of x\n\n\n\n\n\n\ntrv\n (\"trivial\"): always true; gives no information\n\n\n\n\n\n\nill\n (\"ill-formed\"): Not an Interval (an error occurred), e.g. Dom(f) = empty\n\n\n\n\n\n\nInitialisation\n\n\nEach decorated interval is initialised with a decoration according to the status of its interval \nx\n (pg. 46 of the standard):\n\n\n\n\ncom\n: if \nx\n is nonempty and bounded;\n\n\ndac\n if \nx\n is unbounded;\n\n\ntrv\n if \nx\n is empty.\n\n\n\n\nAction of functions\n\n\nA decoration is the combination of an interval together with the sequence of functions that it has passed through.\n\n\nAs an example, consider the \nsqrt\n function acting on an interval \nx\n.\n\n\nIf \nx\n is empty, then \nsqrt\n will return the, empty interval, together with the trivial decoration.\n\n\nIf \nx\n is [a, Inf] with a \n 0 (\ndac\n), then \nsqrt(x)\n will return \n[sqrt(a), Inf]\n, so is also unbounded, and so will return (\n[sqrt(a), Inf], dac\n).\n\n\nThe domain of \nsqrt\n is \nD := Dom(sqrt) = [0, Inf]\n. We must first check if\n\nx \u2286 D\n. If so, then the \nsqrt\n function is continuous and bounded on that interval, so we return \nmin(\ncom\n, decoration(x))\n,  where \ndecoration(x)\n is the decoration of \nx\n.\n\n\nE.g. consider the \nsign\n function:\nsign(x) = 1, if x \n 0; sign(x) = 0 if x = 0; sign(x) = -1 if x \n 0\n\n\nThis function is defined for all x in R, but is not continuous at 0. Thus if the interval contains 0, the decoration that results cannot be better than \ndef\n.\nThus \nsqrt(sign([0,10]))\n will return \n([0,1], def)\n, where the decoration is only \ndef\n, indicating that we cannot guarantee that the function \nsqrt \u2218 sign\n is continuous on the interval. (In fact, we know that it is not continuous, but this is not guaranteed by the decoration.)", 
            "title": "Decorations"
        }, 
        {
            "location": "/decorations/#decorations", 
            "text": "Decorations are flags or labels attached to intervals to indicate the status of a given interval as the product of a function evaluation on a given initial interval.  The possible decorations and their ordering are as follows (pg. 46): com     dac     def     trv     ill .    com  (\"common\"): The meanings are (pg. 44): x is a bounded, nonempty subset of Dom(f); f is\ncontinuous at each point of x; and the computed interval f(x) is bounded.\nx is a nonempty subset of Dom(f), and the restriction of f to x is continuous;    dac  (\"defined   continuous\"): x is a nonempty subset of Dom(f), and the\nrestriction of f to x is continuous;    def  (\"defined\"): x is a nonempty subset of Dom(f), i.e. f is defined at each point of x    trv  (\"trivial\"): always true; gives no information    ill  (\"ill-formed\"): Not an Interval (an error occurred), e.g. Dom(f) = empty", 
            "title": "Decorations:"
        }, 
        {
            "location": "/decorations/#initialisation", 
            "text": "Each decorated interval is initialised with a decoration according to the status of its interval  x  (pg. 46 of the standard):   com : if  x  is nonempty and bounded;  dac  if  x  is unbounded;  trv  if  x  is empty.", 
            "title": "Initialisation"
        }, 
        {
            "location": "/decorations/#action-of-functions", 
            "text": "A decoration is the combination of an interval together with the sequence of functions that it has passed through.  As an example, consider the  sqrt  function acting on an interval  x .  If  x  is empty, then  sqrt  will return the, empty interval, together with the trivial decoration.  If  x  is [a, Inf] with a   0 ( dac ), then  sqrt(x)  will return  [sqrt(a), Inf] , so is also unbounded, and so will return ( [sqrt(a), Inf], dac ).  The domain of  sqrt  is  D := Dom(sqrt) = [0, Inf] . We must first check if x \u2286 D . If so, then the  sqrt  function is continuous and bounded on that interval, so we return  min( com , decoration(x)) ,  where  decoration(x)  is the decoration of  x .  E.g. consider the  sign  function:\nsign(x) = 1, if x   0; sign(x) = 0 if x = 0; sign(x) = -1 if x   0  This function is defined for all x in R, but is not continuous at 0. Thus if the interval contains 0, the decoration that results cannot be better than  def .\nThus  sqrt(sign([0,10]))  will return  ([0,1], def) , where the decoration is only  def , indicating that we cannot guarantee that the function  sqrt \u2218 sign  is continuous on the interval. (In fact, we know that it is not continuous, but this is not guaranteed by the decoration.)", 
            "title": "Action of functions"
        }
    ]
}