{
    "docs": [
        {
            "location": "/", 
            "text": "ValidatedNumerics.jl\n\n\nValidatedNumerics.jl\n is a Julia package for performing \nValidated Numerics\n in Julia, i.e. \nrigorous\n computations with finite-precision floating-point arithmetic.\n\n\nInstallation\n\n\nTo install the package, from within Julia do\n\n\njulia\n Pkg.add(\"ValidatedNumerics\")\n\n\n\nInterval arithmetic\n\n\nAll calculations are carried out using \ninterval arithmetic\n: all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is \nguaranteed\n to contain the correct result, starting from the given initial data.\n\n\nThe aim of the package is correctness over speed, although performance considerations are also taken into account\n\n\nContents:\n\n\n\n\nBasic usage\n\n\nRoot finding\n\n\nRounding\n\n\n\n\nBibliography\n\n\n\n\nValidated Numerics: A Short Introduction to Rigorous Computations\n, W. Tucker, Princeton University Press (2010)\n\n\nIntroduction to Interval Analysis\n, R.E. Moore, R.B. Kearfott \n M.J. Cloud, SIAM (2009)\n\n\n\n\nRelated packages\n\n\n\n\nMPFI.jl\n, a Julia wrapper around the \nMPFI C library\n, a multiple-precision interval arithmetic library based on MPFR\n\n\nIntervals.jl\n, an alternative implementation of basic interval functions.\n\n\n\n\nAuthors\n\n\n\n\nLuis Benet\n, Instituto de Ciencias F\u00edsicas,\nUniversidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\nDavid P. Sanders\n,\nDepartamento de F\u00edsica, Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)\n\n\n\n\nContributors\n\n\n\n\nNikolay Kryukov\n\n\nJohn Verzani\n\n\n\n\nAcknowledgements\n\n\nThis project was developed in a masters' course in the postgraduate programs in Physics and in Mathematics at UNAM during the second semester of 2013 and the first semester of 2015. We thank the participants of the courses for putting up with the half-baked material and contributing energy and ideas.\n\n\nFinancial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214. LB acknowledges support through a \nC\u00e1tedra Moshinsky\n (2013).", 
            "title": "Validated Numerics package"
        }, 
        {
            "location": "/#validatednumericsjl", 
            "text": "ValidatedNumerics.jl  is a Julia package for performing  Validated Numerics  in Julia, i.e.  rigorous  computations with finite-precision floating-point arithmetic.", 
            "title": "ValidatedNumerics.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "To install the package, from within Julia do  julia  Pkg.add(\"ValidatedNumerics\")", 
            "title": "Installation"
        }, 
        {
            "location": "/#interval-arithmetic", 
            "text": "All calculations are carried out using  interval arithmetic : all quantities are treated as intervals, which are propagated throughout a calculation. The final result is an interval that is  guaranteed  to contain the correct result, starting from the given initial data.  The aim of the package is correctness over speed, although performance considerations are also taken into account", 
            "title": "Interval arithmetic"
        }, 
        {
            "location": "/#contents", 
            "text": "Basic usage  Root finding  Rounding", 
            "title": "Contents:"
        }, 
        {
            "location": "/#bibliography", 
            "text": "Validated Numerics: A Short Introduction to Rigorous Computations , W. Tucker, Princeton University Press (2010)  Introduction to Interval Analysis , R.E. Moore, R.B. Kearfott   M.J. Cloud, SIAM (2009)", 
            "title": "Bibliography"
        }, 
        {
            "location": "/#related-packages", 
            "text": "MPFI.jl , a Julia wrapper around the  MPFI C library , a multiple-precision interval arithmetic library based on MPFR  Intervals.jl , an alternative implementation of basic interval functions.", 
            "title": "Related packages"
        }, 
        {
            "location": "/#authors", 
            "text": "Luis Benet , Instituto de Ciencias F\u00edsicas,\nUniversidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)  David P. Sanders ,\nDepartamento de F\u00edsica, Facultad de Ciencias, Universidad Nacional Aut\u00f3noma de M\u00e9xico (UNAM)", 
            "title": "Authors"
        }, 
        {
            "location": "/#contributors", 
            "text": "Nikolay Kryukov  John Verzani", 
            "title": "Contributors"
        }, 
        {
            "location": "/#acknowledgements", 
            "text": "This project was developed in a masters' course in the postgraduate programs in Physics and in Mathematics at UNAM during the second semester of 2013 and the first semester of 2015. We thank the participants of the courses for putting up with the half-baked material and contributing energy and ideas.  Financial support is acknowledged from DGAPA-UNAM PAPIME grants PE-105911 and PE-107114, and DGAPA-UNAM PAPIIT grant IN-117214. LB acknowledges support through a  C\u00e1tedra Moshinsky  (2013).", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/usage/", 
            "text": "MathJax.Hub.Config({\n    TeX: { equationNumbers: { autoNumber: \"AMS\" } }\n  });\n  MathJax.Hub.Config({\n    TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\", \"autobold.js\", \"autoload-all.js\"] }\n  });\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n      processEscapes: true\n    }\n  });\n\n\n\n\n\n\n\n\n\nBasic usage\n\n\nThe basic elements of the package are \nintervals\n, i.e. sets of real numbers (possibly including $\\pm \\infty$) of the form\n\n\n$$[a, b] := { a \\le x \\le b } \\subseteq \\mathbb{R}.$$\n\n\nCreating intervals\n\n\nIntervals are created using the \n@interval\n macro, which takes one or two expressions:\n\n\njulia\n using ValidatedNumerics\n\njulia\n a = @interval(1)\n[1.0, 1.0]\n\njulia\n typeof(ans)\nInterval{Float64} (constructor with 1 method)\n\njulia\n\n\njulia\n b = @interval(1, 2)\n[1.0, 2.0]\n\n\n\n\nThese return objects of the parametrised type \nInterval\n, the basic object in the package.\n\n\nThe constructor of the \nInterval\n type may be used directly, but this is generally not recommended, for the following reason:\n\n\njulia\n a = Interval(0.1, 0.3)\n[0.1, 0.3]\n\njulia\n b = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]\n\n\n\n\nWhat is going on here?\n\n\nDue to the way floating-point arithmetic works, the interval\n\na\n created directly by the constructor \ncontains neither the true real number 0.1, nor 0.3\n.\nThe \n@interval\n macro, however, uses \ndirected rounding\n to \nguarantee\n\nthat the true 0.1 and 0.3 are included in the result.\n\n\nBehind the scenes, the \n@interval\n macro rewrites the expression(s) passed to it, replacing the literals (0.1, 1, etc.) by calls to create correctly-rounded intervals, handled internally by the \nmake_interval\n function.\n\n\nThis allows us to write, for example\n\n\njulia\n @interval sin(0.1) + cos(0.2)\n\n\n\n\nand get a result that is equivalent to\n\n\njulia\n sin(@interval(0.1)) + cos(@interval(0.2))\n\n\n\n\nThis can also be used with user-defined functions:\n\n\njulia\n f(x) = 2x\nf (generic function with 1 method)\n\njulia\n f(@interval(0.1))\n[0.19999999999999998, 0.2]\n\njulia\n @interval f(0.1)\n[0.19999999999999998, 0.2]\n\n\n\n\n$\\pi$\n\n\nYou can create correctly-rounded intervals containing $\\pi$:\n\n\njulia\n @interval(pi)\n[3.141592653589793, 3.1415926535897936]\n\n\n\n\nand embed it in expressions:\n\n\njulia\n @interval(3*pi/2 + 1)\n[5.71238898038469, 5.712388980384691]\n\njulia\n @interval 3\u03c0/2 + 1\n[5.71238898038469, 5.712388980384691]\n\n\n\n\nExamples\n\n\nIntervals may be constructed using rationals:\n\n\njulia\n @interval(1//10)\n[0.09999999999999999, 0.1]\n\n\n\n\nReals are converted to rationals:\n\n\njulia\n @interval(0.1)\n[0.09999999999999999, 0.1]\n\n\n\n\nStrings may be used:\n\n\njulia\n @interval(\n0.1\n*\n2\n)\n[0.19999999999999998, 0.2]\n\n\n\n\nStrings in the form of intervals may also be used:\n\n\njulia\n @interval \n[1.2, 3.4]\n\n[1.2, 3.4000000000000004]\n\n\n\n\nIntervals can be created from variables:\n\n\njulia\n a = 3.6\n3.6\n\njulia\n b = @interval(a)\n[3.5999999999999996, 3.6000000000000005]\n\n\n\n\nThe upper and lower bounds of the interval may be accessed using the fields\n\nlo\n and \nhi\n:\n\n\njulia\n b.lo\n3.5999999999999996\n\njulia\n b.hi\n3.6000000000000005\n\n\n\n\nThe diameter (length) of an interval is obtained using \ndiam(b)\n;\nfor numbers that cannot be represented in base 2\n(i.e., whose \nbinary\n expansion is infinite or exceeds the current precision),\n the diameter of newly-created thin intervals corresponds to the local machine epsilon (\neps\n) in the \n:narrow\n interval rounding mode:\n\n\njulia\n diam(b)\n8.881784197001252e-16\n\n\n\n\n\nArithmetic\n\n\nBasic arithmetic operations (\n+\n, \n-\n, \n*\n, \n/\n, \n^\n) are defined for pairs of intervals in a standard way (see, e.g., the book by Tucker): the result is the smallest interval containing the result of operating with each element of each interval. That is, for two intervals $X$ and $Y$ and an operation $\\circ$, we define the operation on the two intervals by\n$$X \\circ Y := { x \\circ y: x \\in X \\text{ and } y \\in Y }.$$  Again, directed rounding is used if necessary.\n\n\nFor example:\n\n\njulia\n a = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]\n\njulia\n b = @interval(0.3, 0.6)\n[0.29999999999999993, 0.6000000000000001]\n\njulia\n a + b\n[0.3999999999999999, 0.9000000000000001]\n\n\n\n\nHowever, subtraction of two intervals gives an initially unexpected result, due to the above definition:\n\n\njulia\n a = @interval(0, 1)\n[0.0, 1.0]\n\njulia\n a - a\n[-1.0, 1.0]\n\n\n\n\nChanging the precision\n\n\nBy default, the \n@interval\n macro creates intervals of \nFloat64\ns.\nThis may be changed using the \nset_interval_precision\n function:\n\n\njulia\n set_interval_precision(256)\n256\n\njulia\n @interval 3\u03c0/2 + 1\n[5.712388980384689857693965074919254326295754099062658731462416888461724609429262e+00, 5.712388980384689857693965074919254326295754099062658731462416888461724609429401e+00]\u2082\u2085\u2086\n\n\n\n\nThe subscript \n256\n at the end denotes the precision.\n\n\nTo change back to \nFloat64\ns, use\n\n\njulia\n set_interval_precision(Float64)\nFloat64\n\njulia\n @interval(pi)\n[3.141592653589793, 3.1415926535897936]\n\n\n\n\nTo check which mode is currently set, use\n\n\njulia\n get_interval_precision()\n(Float64,-1)\n\n\n\n\nThe result is a tuple of the type (currently \nFloat64\n or \nBigFloat\n) and the precision (relevant only for \nBigFloat\ns).\n\n\nNB: The standard Julia function \nset_bigfloat_precision\n is used internally by \nset_interval_precision\n, but it should not be used directly, since \nset_interval_precision\n carries out additional steps to ensure internal consistency of certain interval operations.\n\n\nElementary functions\n\n\nThe main elementary functions are defined, acting on interval arguments.\nCurrently, \nexp\n, \nlog\n, \nsin\n, \ncos\n and \ntan\n are implemented, e.g.\n\n\njulia\n sin(@interval(1))\n[0.8414709848078965, 0.8414709848078965]\n\n\n\n\nAgain, the result should contain the result of applying the function to each real number contained in the interval.\n\n\nHowever\n, as can be seen from the above result, currently \ndirected rounding is \nnot\n implemented\n for elementary functions of \nFloat64\ns. [We are aiming to incorporate this functionality in v0.2 via the \ncrlibm\n package\n.]\n\n\nCurrently, this may be correctly calculated by using \nBigFloat\ns with a precision of 53 bits (the same as that of \nFloat64\ns):\n\n\njulia\n set_interval_precision(53)\n53\n\njulia\n sin(@interval(1))\n[8.414709848078965e-01, 8.4147098480789662e-01]\u2085\u2083\n\njulia\n @interval sin(0.1) + cos(0.2)\n[1.0798999944880696e+00, 1.0798999944880701e+00]\u2085\u2083\n\n\n\n\nNote, however, that calculations with \nBigFloat\ns are carried out in software, and so are slower than operating with  \nFloat64\ns directly.\n\n\nInterval rounding modes\n\n\nBy default, the directed rounding used corresponds to using the \nRoundDown\n and \nRoundUp\n rounding modes when performing calculations; this gives the narrowest resulting intervals, and is set by\n\n\nset_interval_rounding(:narrow)\n\n\n\n\nAn alternative rounding method is to perform calculations using the (standard) \nRoundNearest\n rounding mode, and then widen the result by one machine epsilon in each direction using \nprevfloat\n and \nnextfloat\n. This is achived by\n\n\nset_interval_rounding(:wide)\n\n\n\n\nIt generally results in wider intervals, but seems to be significantly faster.\n\n\nThe current interval rounding mode may be obtained by\n\n\nget_interval_rounding()", 
            "title": "Basic usage"
        }, 
        {
            "location": "/usage/#basic-usage", 
            "text": "The basic elements of the package are  intervals , i.e. sets of real numbers (possibly including $\\pm \\infty$) of the form  $$[a, b] := { a \\le x \\le b } \\subseteq \\mathbb{R}.$$", 
            "title": "Basic usage"
        }, 
        {
            "location": "/usage/#creating-intervals", 
            "text": "Intervals are created using the  @interval  macro, which takes one or two expressions:  julia  using ValidatedNumerics\n\njulia  a = @interval(1)\n[1.0, 1.0]\n\njulia  typeof(ans)\nInterval{Float64} (constructor with 1 method)\n\njulia \n\njulia  b = @interval(1, 2)\n[1.0, 2.0]  These return objects of the parametrised type  Interval , the basic object in the package.  The constructor of the  Interval  type may be used directly, but this is generally not recommended, for the following reason:  julia  a = Interval(0.1, 0.3)\n[0.1, 0.3]\n\njulia  b = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]  What is going on here?  Due to the way floating-point arithmetic works, the interval a  created directly by the constructor  contains neither the true real number 0.1, nor 0.3 .\nThe  @interval  macro, however, uses  directed rounding  to  guarantee \nthat the true 0.1 and 0.3 are included in the result.  Behind the scenes, the  @interval  macro rewrites the expression(s) passed to it, replacing the literals (0.1, 1, etc.) by calls to create correctly-rounded intervals, handled internally by the  make_interval  function.  This allows us to write, for example  julia  @interval sin(0.1) + cos(0.2)  and get a result that is equivalent to  julia  sin(@interval(0.1)) + cos(@interval(0.2))  This can also be used with user-defined functions:  julia  f(x) = 2x\nf (generic function with 1 method)\n\njulia  f(@interval(0.1))\n[0.19999999999999998, 0.2]\n\njulia  @interval f(0.1)\n[0.19999999999999998, 0.2]  $\\pi$  You can create correctly-rounded intervals containing $\\pi$:  julia  @interval(pi)\n[3.141592653589793, 3.1415926535897936]  and embed it in expressions:  julia  @interval(3*pi/2 + 1)\n[5.71238898038469, 5.712388980384691]\n\njulia  @interval 3\u03c0/2 + 1\n[5.71238898038469, 5.712388980384691]", 
            "title": "Creating intervals"
        }, 
        {
            "location": "/usage/#examples", 
            "text": "Intervals may be constructed using rationals:  julia  @interval(1//10)\n[0.09999999999999999, 0.1]  Reals are converted to rationals:  julia  @interval(0.1)\n[0.09999999999999999, 0.1]  Strings may be used:  julia  @interval( 0.1 * 2 )\n[0.19999999999999998, 0.2]  Strings in the form of intervals may also be used:  julia  @interval  [1.2, 3.4] \n[1.2, 3.4000000000000004]  Intervals can be created from variables:  julia  a = 3.6\n3.6\n\njulia  b = @interval(a)\n[3.5999999999999996, 3.6000000000000005]  The upper and lower bounds of the interval may be accessed using the fields lo  and  hi :  julia  b.lo\n3.5999999999999996\n\njulia  b.hi\n3.6000000000000005  The diameter (length) of an interval is obtained using  diam(b) ;\nfor numbers that cannot be represented in base 2\n(i.e., whose  binary  expansion is infinite or exceeds the current precision),\n the diameter of newly-created thin intervals corresponds to the local machine epsilon ( eps ) in the  :narrow  interval rounding mode:  julia  diam(b)\n8.881784197001252e-16", 
            "title": "Examples"
        }, 
        {
            "location": "/usage/#arithmetic", 
            "text": "Basic arithmetic operations ( + ,  - ,  * ,  / ,  ^ ) are defined for pairs of intervals in a standard way (see, e.g., the book by Tucker): the result is the smallest interval containing the result of operating with each element of each interval. That is, for two intervals $X$ and $Y$ and an operation $\\circ$, we define the operation on the two intervals by\n$$X \\circ Y := { x \\circ y: x \\in X \\text{ and } y \\in Y }.$$  Again, directed rounding is used if necessary.  For example:  julia  a = @interval(0.1, 0.3)\n[0.09999999999999999, 0.30000000000000004]\n\njulia  b = @interval(0.3, 0.6)\n[0.29999999999999993, 0.6000000000000001]\n\njulia  a + b\n[0.3999999999999999, 0.9000000000000001]  However, subtraction of two intervals gives an initially unexpected result, due to the above definition:  julia  a = @interval(0, 1)\n[0.0, 1.0]\n\njulia  a - a\n[-1.0, 1.0]", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/usage/#changing-the-precision", 
            "text": "By default, the  @interval  macro creates intervals of  Float64 s.\nThis may be changed using the  set_interval_precision  function:  julia  set_interval_precision(256)\n256\n\njulia  @interval 3\u03c0/2 + 1\n[5.712388980384689857693965074919254326295754099062658731462416888461724609429262e+00, 5.712388980384689857693965074919254326295754099062658731462416888461724609429401e+00]\u2082\u2085\u2086  The subscript  256  at the end denotes the precision.  To change back to  Float64 s, use  julia  set_interval_precision(Float64)\nFloat64\n\njulia  @interval(pi)\n[3.141592653589793, 3.1415926535897936]  To check which mode is currently set, use  julia  get_interval_precision()\n(Float64,-1)  The result is a tuple of the type (currently  Float64  or  BigFloat ) and the precision (relevant only for  BigFloat s).  NB: The standard Julia function  set_bigfloat_precision  is used internally by  set_interval_precision , but it should not be used directly, since  set_interval_precision  carries out additional steps to ensure internal consistency of certain interval operations.", 
            "title": "Changing the precision"
        }, 
        {
            "location": "/usage/#elementary-functions", 
            "text": "The main elementary functions are defined, acting on interval arguments.\nCurrently,  exp ,  log ,  sin ,  cos  and  tan  are implemented, e.g.  julia  sin(@interval(1))\n[0.8414709848078965, 0.8414709848078965]  Again, the result should contain the result of applying the function to each real number contained in the interval.  However , as can be seen from the above result, currently  directed rounding is  not  implemented  for elementary functions of  Float64 s. [We are aiming to incorporate this functionality in v0.2 via the  crlibm  package .]  Currently, this may be correctly calculated by using  BigFloat s with a precision of 53 bits (the same as that of  Float64 s):  julia  set_interval_precision(53)\n53\n\njulia  sin(@interval(1))\n[8.414709848078965e-01, 8.4147098480789662e-01]\u2085\u2083\n\njulia  @interval sin(0.1) + cos(0.2)\n[1.0798999944880696e+00, 1.0798999944880701e+00]\u2085\u2083  Note, however, that calculations with  BigFloat s are carried out in software, and so are slower than operating with   Float64 s directly.", 
            "title": "Elementary functions"
        }, 
        {
            "location": "/usage/#interval-rounding-modes", 
            "text": "By default, the directed rounding used corresponds to using the  RoundDown  and  RoundUp  rounding modes when performing calculations; this gives the narrowest resulting intervals, and is set by  set_interval_rounding(:narrow)  An alternative rounding method is to perform calculations using the (standard)  RoundNearest  rounding mode, and then widen the result by one machine epsilon in each direction using  prevfloat  and  nextfloat . This is achived by  set_interval_rounding(:wide)  It generally results in wider intervals, but seems to be significantly faster.  The current interval rounding mode may be obtained by  get_interval_rounding()", 
            "title": "Interval rounding modes"
        }, 
        {
            "location": "/root_finding/", 
            "text": "MathJax.Hub.Config({\n    TeX: { equationNumbers: { autoNumber: \"AMS\" } }\n  });\n  MathJax.Hub.Config({\n    TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\", \"autobold.js\", \"autoload-all.js\"] }\n  });\n  MathJax.Hub.Config({\n    tex2jax: {\n      inlineMath: [['$','$'], ['\\\\(','\\\\)']],\n      processEscapes: true\n    }\n  });\n\n\n\n\n\n\n\n\n\nRoot finding\n\n\nInterval arithmetic not only provides guaranteed numerical calculations; it also\nmakes possible fundamentally new algorithms.\n\n\nInterval Newton method\n\n\nOne such algorithm is the \ninterval Newton method\n. This is a version of the\nstandard Newton (or Newton-Raphson) algorithm, an iterative method for finding\nroots (zeros) of functions.\nThe interval version, however, is fundamentally different from its standard\ncounterpart, in that it can (under the best circumstances) provide rigorous\n\nguarantees\n about the presence or absence and uniqueness of roots of a given\nfunction in a given interval, and tells us explicitly when it is unable to\nprovide such a guarantee.\n\n\nThe idea of the Newton method is to calculate a root $x^\\ast$ of a function\n$f$ [i.e., a value such that $f(x^*) = 0$] from an initial guess $x$ using\n\n\n$$x^* = x - \\frac{f(x)}{f'(\\xi)},$$\n\n\nfor some $\\xi$ between $x$ and $x^*$. Since $\\xi$ is unknown, we can bound it as\n\n\n$$f'(\\xi) \\in F'(X),$$\n\n\nwhere $X$ is a containing interval and $F'(X)$ denotes the \ninterval extension\n\nof the function $f$, consisting of applying the same operations as the function\n$f$ to the interval $X$.\n\n\nWe define an \ninterval Newton operator\n $\\mathcal{N}$ as follows:\n\n\n$$\\mathcal{N}(X) := m(X) - \\frac{F(m(X))}{F'(X)},$$\n\n\nwhere $m(X)$  is the midpoint of $X$ converted into an interval.\n\n\nIt turns out that $\\mathcal{N}$ tells us precisely whether there is a root of $f$ in\nthe interval $X$: there is no root if $\\mathcal{N}(X) \\cap X = \\emptyset$, and there is\na unique root if $\\mathcal{N}(X) \\subseteq X$.\nThere is also an extension to intervals in which the derivative $F'(X)$ contains $0$,\nin which case the Newton operator returns a union of two intervals.\n\n\nIterating the Newton operator on the resulting sets gives a rigorous algorithm\nthat is \nguaranteed to find all roots\n of a\nreal function in a given interval (or to inform us if it is unable to do so,\nfor example at a multiple root); see Tucker's book for more details.\n\n\nUsage of the interval Newton method\n\n\nThe interval Newton method is implemented for real functions of a single\nvariable as the function \nnewton\n. For example, we can calculate rigorously the square roots of 2:\n\n\njulia\n using ValidatedNumerics\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\n\n\n\nThe function \nnewton\n  is passed the function and the interval in which to search for roots;\nit returns an array of \nRoot\n objects, that contain the interval where a root is found,\ntogether with a symbol \n:unique\n if there is guaranteed to be a unique root in that\ninterval, or \n:unknown\n if the Newton method is unable to make a guarantee, for example,\nwhen there is a double root:\n\n\njulia\n newton(f, @interval(-5,5))\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([2.0, 2.0], :unique)\n\n\n\n\nThe Newton method may be applied directly to a vector of known roots,\nfor example to refine them with higher precision:\n\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n roots = newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\njulia\n set_interval_precision(256)\n256\n\njulia\n newton(f, roots)\n2-element Array{ValidatedNumerics.Root{Base.MPFR.BigFloat},1}:\n Root([-1.414213562373095048801688724209698078569671875376948073176679737990732478462119, -1.414213562373095048801688724209698078569671875376948073176679737990732478462102]\u2082\u2085\u2086, :unique)\n Root([1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1.414213562373095048801688724209698078569671875376948073176679737990732478462119]\u2082\u2085\u2086, :unique)\n\njulia\n abs(roots2[2].interval.lo - sqrt(big(2)))\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000\n\n\n\n\n\nKrawczyk method\n\n\nAn alternative method is the \nKrawczyk method\n, implemented in the function\n\nkrawczyk\n, with the same interface as the Newton method:\n\n\njulia\n f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia\n krawczyk(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730954, -1.4142135623730947], :unique)\n Root([1.4142135623730947, 1.4142135623730954], :unique)\n\njulia\n newton(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\n\n\n\nThe Krawczyk method really comes into its own for higher-dimensional functions;\nthis is planned to be implemented in the future.\n\n\nfind_roots\n interface\n\n\nAutomatic differentiation is used to calculate the derivative used in the Newton method\nif the derivative function is not given explicitly as the second argument to \nnewton\n.\n\n\nAn interface \nfind_roots\n is provided, which does not require an interval to be passed:\n\n\njulia\n find_roots(f, -5, 5)\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([1.9999999999999998, 2.0000000000000004], :unique)\n\n\n\n\nThere is also a version \nfind_roots_midpoint\n that returns three vectors:\nthe midpoint of each interval; the radius of the interval; and the symbol.\nThis may be useful for someone who just wishes to find roots of a function,\nwithout wanting to understand how to manipulate interval objects:\n\n\njulia\n find_roots_midpoint(f, -5, 5)\n([-1.4142135623730951,1.414213562373095],[2.220446049250313e-16,4.440892098500626e-16],[:unique,:unique])\n\n\n\n\nThis uses the function \nmidpoint_radius\n, that returns the midpoint and radius\nof a given interval:\n\n\njulia\n a = @interval(0.1, 0.2)\n[0.09999999999999999, 0.2]\n\njulia\n midpoint_radius(a)\n(0.15,0.05000000000000002)", 
            "title": "Root finding"
        }, 
        {
            "location": "/root_finding/#root-finding", 
            "text": "Interval arithmetic not only provides guaranteed numerical calculations; it also\nmakes possible fundamentally new algorithms.", 
            "title": "Root finding"
        }, 
        {
            "location": "/root_finding/#interval-newton-method", 
            "text": "One such algorithm is the  interval Newton method . This is a version of the\nstandard Newton (or Newton-Raphson) algorithm, an iterative method for finding\nroots (zeros) of functions.\nThe interval version, however, is fundamentally different from its standard\ncounterpart, in that it can (under the best circumstances) provide rigorous guarantees  about the presence or absence and uniqueness of roots of a given\nfunction in a given interval, and tells us explicitly when it is unable to\nprovide such a guarantee.  The idea of the Newton method is to calculate a root $x^\\ast$ of a function\n$f$ [i.e., a value such that $f(x^*) = 0$] from an initial guess $x$ using  $$x^* = x - \\frac{f(x)}{f'(\\xi)},$$  for some $\\xi$ between $x$ and $x^*$. Since $\\xi$ is unknown, we can bound it as  $$f'(\\xi) \\in F'(X),$$  where $X$ is a containing interval and $F'(X)$ denotes the  interval extension \nof the function $f$, consisting of applying the same operations as the function\n$f$ to the interval $X$.  We define an  interval Newton operator  $\\mathcal{N}$ as follows:  $$\\mathcal{N}(X) := m(X) - \\frac{F(m(X))}{F'(X)},$$  where $m(X)$  is the midpoint of $X$ converted into an interval.  It turns out that $\\mathcal{N}$ tells us precisely whether there is a root of $f$ in\nthe interval $X$: there is no root if $\\mathcal{N}(X) \\cap X = \\emptyset$, and there is\na unique root if $\\mathcal{N}(X) \\subseteq X$.\nThere is also an extension to intervals in which the derivative $F'(X)$ contains $0$,\nin which case the Newton operator returns a union of two intervals.  Iterating the Newton operator on the resulting sets gives a rigorous algorithm\nthat is  guaranteed to find all roots  of a\nreal function in a given interval (or to inform us if it is unable to do so,\nfor example at a multiple root); see Tucker's book for more details.", 
            "title": "Interval Newton method"
        }, 
        {
            "location": "/root_finding/#usage-of-the-interval-newton-method", 
            "text": "The interval Newton method is implemented for real functions of a single\nvariable as the function  newton . For example, we can calculate rigorously the square roots of 2:  julia  using ValidatedNumerics\n\njulia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)  The function  newton   is passed the function and the interval in which to search for roots;\nit returns an array of  Root  objects, that contain the interval where a root is found,\ntogether with a symbol  :unique  if there is guaranteed to be a unique root in that\ninterval, or  :unknown  if the Newton method is unable to make a guarantee, for example,\nwhen there is a double root:  julia  newton(f, @interval(-5,5))\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([2.0, 2.0], :unique)  The Newton method may be applied directly to a vector of known roots,\nfor example to refine them with higher precision:  julia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  roots = newton(f, @interval(-5, 5))\n2-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)\n\njulia  set_interval_precision(256)\n256\n\njulia  newton(f, roots)\n2-element Array{ValidatedNumerics.Root{Base.MPFR.BigFloat},1}:\n Root([-1.414213562373095048801688724209698078569671875376948073176679737990732478462119, -1.414213562373095048801688724209698078569671875376948073176679737990732478462102]\u2082\u2085\u2086, :unique)\n Root([1.414213562373095048801688724209698078569671875376948073176679737990732478462102, 1.414213562373095048801688724209698078569671875376948073176679737990732478462119]\u2082\u2085\u2086, :unique)\n\njulia  abs(roots2[2].interval.lo - sqrt(big(2)))\n0.000000000000000000000000000000000000000000000000000000000000000000000000000000", 
            "title": "Usage of the interval Newton method"
        }, 
        {
            "location": "/root_finding/#krawczyk-method", 
            "text": "An alternative method is the  Krawczyk method , implemented in the function krawczyk , with the same interface as the Newton method:  julia  f(x) = x^2 - 2\nf (generic function with 1 method)\n\njulia  krawczyk(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730954, -1.4142135623730947], :unique)\n Root([1.4142135623730947, 1.4142135623730954], :unique)\n\njulia  newton(f, @interval(-5, 5))\n2-element Array{Root{Float64},1}:\n Root([-1.4142135623730951, -1.414213562373095], :unique)\n Root([1.414213562373095, 1.4142135623730951], :unique)  The Krawczyk method really comes into its own for higher-dimensional functions;\nthis is planned to be implemented in the future.", 
            "title": "Krawczyk method"
        }, 
        {
            "location": "/root_finding/#find_roots-interface", 
            "text": "Automatic differentiation is used to calculate the derivative used in the Newton method\nif the derivative function is not given explicitly as the second argument to  newton .  An interface  find_roots  is provided, which does not require an interval to be passed:  julia  find_roots(f, -5, 5)\n6-element Array{ValidatedNumerics.Root{Float64},1}:\n Root([0.9999999968789343, 0.999999997726216], :unknown)\n Root([0.9999999977262161, 0.9999999985734976], :unknown)\n Root([0.9999999987089422, 0.9999999993384274], :unknown)\n Root([0.9999999993384275, 0.9999999999679127], :unknown)\n Root([0.9999999999687099, 1.0000000004524654], :unknown)\n Root([1.9999999999999998, 2.0000000000000004], :unique)  There is also a version  find_roots_midpoint  that returns three vectors:\nthe midpoint of each interval; the radius of the interval; and the symbol.\nThis may be useful for someone who just wishes to find roots of a function,\nwithout wanting to understand how to manipulate interval objects:  julia  find_roots_midpoint(f, -5, 5)\n([-1.4142135623730951,1.414213562373095],[2.220446049250313e-16,4.440892098500626e-16],[:unique,:unique])  This uses the function  midpoint_radius , that returns the midpoint and radius\nof a given interval:  julia  a = @interval(0.1, 0.2)\n[0.09999999999999999, 0.2]\n\njulia  midpoint_radius(a)\n(0.15,0.05000000000000002)", 
            "title": "find_roots interface"
        }, 
        {
            "location": "/rounding/", 
            "text": "Why is rounding necessary?\n\n\nConsider the Julia code\n\n\nx = 0.1\n\n\n\nThis apparently stores the value 0.1 in a variable \nx\n of type \nFloat64\n.\nIn fact, however, it stores a \nslightly different\n number than 0.1, since 0.1 itself \ncannot be represented in binary floating point arithmetic, at any precision\n.\n\n\nThe value that is actually stored in the variable can be conveniently determined in Julia using arbitrary precision arithmetic (\nBigFloat\ns):\n\n\njulia\n big(0.1)\n\n1.000000000000000055511151231257827021181583404541015625e-01 with 256 bits of precision\n\n\n\nSo, in fact, the value is slightly greater than 0.1. By default, such calculations are done in round-to-nearest mode (\nRoundNearest\n); i.e., the nearest representable floating-point number to 0.1 is used.\n\n\nSuppose now that we created an interval as\n\n\njulia\n II = Interval(0.1)\n[0.1, 0.1]\n\n\n\nIt looks like the interval contains the true value 0.1, but from the above discussion we see that, in fact, \nit does not\n. In order to contain the true value 0.1, the end-points of the interval must be rounded outwards (\"directed rounding\"): the lower bound is rounded down, and the upper bound is rounded up.\n\n\nThis rounding is handled by the \n@interval\n  macro, which generates correctly-rounded intervals:\n\n\njulia\n a = @interval(0.1)\n[0.09999999999999999, 0.1]\n\n\n\n\nThe true 0.1 is now correctly contained in the intervals, so that any calculations on these intervals will contain the true result of calculating with 0.1. For example, if we define\n\n\njulia\n f(x) = 2x + 0.2\n\n\n\n\nthen we can apply the function \nf\n to the interval \na\n to obtain\n\n\njulia\n f(a)\n[0.39999999999999997, 0.4]\n\n\n\n\nThe result correctly contains the true 0.4.\n\n\nMore detail\n\n\nLet's look at the internal representation of the \nFloat64\n number 0.1:\n\n\njulia\n bits(0.1)\n\n0011111110111001100110011001100110011001100110011001100110011010\n\n\n\n\n\nThe last 53 bits of these 64 bits correspond to the binary expansion of 0.1, which is\n\n\n0.000110011001100110011001100110011001100...\n\n\n\n\nWe see that the expansion is periodic; in fact, the binary expansion of 0.1 has an infinite repetition of the sequence of digits \n1100\n. It is thus \nimpossible\n to represent the decimal 0.1 in binary, with \nany\n precision.\n\n\nJulia allows us to get closer to the true value using \nBigFloat\ns:\n\n\njulia\n using Compat\n\njulia\n @compat parse(BigFloat, \n0.1\n)\n1.000000000000000000000000000000000000000000000000000000000000000000000000000002e-01 with 256 bits of precision\n\n\n\n\nBut the 2 and the end of the decimal expansion is the giveaway that this number is still not exactly 0.1\n\n\nThe true value must be approximated by a floating-point number with fixed precision -- this procedure is called \nrounding\n. For positive numbers, rounding down may be accomplished simply by truncating the expansion; rounding up is accomplished by incrementing the final binary digit and propagating any resulting changes.", 
            "title": "Rounding"
        }, 
        {
            "location": "/rounding/#why-is-rounding-necessary", 
            "text": "Consider the Julia code  x = 0.1  This apparently stores the value 0.1 in a variable  x  of type  Float64 .\nIn fact, however, it stores a  slightly different  number than 0.1, since 0.1 itself  cannot be represented in binary floating point arithmetic, at any precision .  The value that is actually stored in the variable can be conveniently determined in Julia using arbitrary precision arithmetic ( BigFloat s):  julia  big(0.1)\n\n1.000000000000000055511151231257827021181583404541015625e-01 with 256 bits of precision  So, in fact, the value is slightly greater than 0.1. By default, such calculations are done in round-to-nearest mode ( RoundNearest ); i.e., the nearest representable floating-point number to 0.1 is used.  Suppose now that we created an interval as  julia  II = Interval(0.1)\n[0.1, 0.1]  It looks like the interval contains the true value 0.1, but from the above discussion we see that, in fact,  it does not . In order to contain the true value 0.1, the end-points of the interval must be rounded outwards (\"directed rounding\"): the lower bound is rounded down, and the upper bound is rounded up.  This rounding is handled by the  @interval   macro, which generates correctly-rounded intervals:  julia  a = @interval(0.1)\n[0.09999999999999999, 0.1]  The true 0.1 is now correctly contained in the intervals, so that any calculations on these intervals will contain the true result of calculating with 0.1. For example, if we define  julia  f(x) = 2x + 0.2  then we can apply the function  f  to the interval  a  to obtain  julia  f(a)\n[0.39999999999999997, 0.4]  The result correctly contains the true 0.4.", 
            "title": "Why is rounding necessary?"
        }, 
        {
            "location": "/rounding/#more-detail", 
            "text": "Let's look at the internal representation of the  Float64  number 0.1:  julia  bits(0.1) 0011111110111001100110011001100110011001100110011001100110011010   The last 53 bits of these 64 bits correspond to the binary expansion of 0.1, which is  0.000110011001100110011001100110011001100...  We see that the expansion is periodic; in fact, the binary expansion of 0.1 has an infinite repetition of the sequence of digits  1100 . It is thus  impossible  to represent the decimal 0.1 in binary, with  any  precision.  Julia allows us to get closer to the true value using  BigFloat s:  julia  using Compat\n\njulia  @compat parse(BigFloat,  0.1 )\n1.000000000000000000000000000000000000000000000000000000000000000000000000000002e-01 with 256 bits of precision  But the 2 and the end of the decimal expansion is the giveaway that this number is still not exactly 0.1  The true value must be approximated by a floating-point number with fixed precision -- this procedure is called  rounding . For positive numbers, rounding down may be accomplished simply by truncating the expansion; rounding up is accomplished by incrementing the final binary digit and propagating any resulting changes.", 
            "title": "More detail"
        }
    ]
}